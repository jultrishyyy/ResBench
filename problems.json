{
    "Combinational Logic": [
        {
            "module": "parity_8bit",
            "Problem": "Implement a Verilog module that computes the parity of an 8-bit input vector. The output should be 1 if the number of '1's in the input is odd, and 0 otherwise.",
            "Module header": "module parity_8bit (\n    input [7:0] in,\n    output out\n);",
            "Testbench": "`timescale 1ns / 1ps\n\nmodule parity_8bit_tb;\n\n    reg [7:0] test_in;   // Input signal\n    wire test_out;       // Output signal\n    reg expected_out;    // Expected output for verification\n    integer errors = 0;  // Error counter\n\n    // Instantiate the module under test\n    parity_8bit uut (\n        .in(test_in),\n        .out(test_out)\n    );\n\n    integer i;\n    reg [7:0] test_vectors[0:4]; // Test cases\n    reg expected_values[0:4];     // Expected results\n\n    initial begin\n        // Define test cases and expected results\n        test_vectors[0] = 8'b00000000; expected_values[0] = 0; // Even parity (0 ones)\n        test_vectors[1] = 8'b11111111; expected_values[1] = 0; // Even parity (8 ones)\n        test_vectors[2] = 8'b00000001; expected_values[2] = 1; // Odd parity (1 one)\n        test_vectors[3] = 8'b10000000; expected_values[3] = 1; // Odd parity (1 one)\n        test_vectors[4] = 8'b01010101; expected_values[4] = 0; // Even parity (4 ones)\n\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        for (i = 0; i < 5; i = i + 1) begin\n            test_in = test_vectors[i];\n            expected_out = expected_values[i];\n            #10; // Wait for the output to stabilize\n\n            if (test_out === expected_out) begin\n                $display(\" %b  |    %b     |   %b   |   PASS\", test_in, expected_out, test_out);\n            end else begin\n                $display(\" %b  |    %b     |   %b   |   FAIL\", test_in, expected_out, test_out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"=====================================\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n\n        $finish;\n    end\n\nendmodule\n"
         },
        {
            "module": "mux4to1",
            "Problem": "Design a Verilog module that implements a 4-to-1 multiplexer using only basic logic gates (AND, OR, NOT).",
            "Module header": "module mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule mux4to1_tb;\n    // Testbench signals\n    reg  [3:0] in;\n    reg  [1:0] sel;\n    wire out;\n    integer errors = 0;\n\n    // Instantiate the DUT (Device Under Test)\n    mux4to1 dut (\n        .in(in),\n        .sel(sel),\n        .out(out)\n    );\n\n    // Task to run a single test.\n    task run_test;\n        input [3:0] test_in;\n        input [1:0] test_sel;\n        reg expected;\n        begin\n            in  = test_in;\n            sel = test_sel;\n            #10;  // Wait for signal propagation.\n            // Compute expected output: the selected bit of the input.\n            expected = (test_sel == 2'b00) ? test_in[0] :\n                       (test_sel == 2'b01) ? test_in[1] :\n                       (test_sel == 2'b10) ? test_in[2] : test_in[3];\n\n            // Display the test result.\n            if (expected === out) begin\n                $display(\" %4b, %2b   |    %b     |   %b   |   PASS\", test_in, test_sel, expected, out);\n            end else begin\n                $display(\" %4b, %2b   |    %b     |   %b   |   FAIL\", test_in, test_sel, expected, out);\n                errors = errors + 1;\n            end\n        end\n    endtask\n\n    initial begin\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test Cases:\n        run_test(4'b0001, 2'b00); // Expected out = in[0] = 1\n        run_test(4'b0010, 2'b01); // Expected out = in[1] = 1\n        run_test(4'b0100, 2'b10); // Expected out = in[2] = 1\n        run_test(4'b1000, 2'b11); // Expected out = in[3] = 1\n        run_test(4'b1010, 2'b10); // For in = 1010, in[2] = 0\n        run_test(4'b1111, 2'b01); // For in = 1111, in[1] = 1\n        run_test(4'b0110, 2'b11); // For in = 0110, in[3] = 0\n\n        $display(\"=====================================\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "majority",
            "Problem": "Write a Verilog module that computes the majority function of three 1-bit inputs. The output should be 1 if at least two inputs are 1, and 0 otherwise.",
            "Module header": "module majority (\n    input a, b, c,\n    output out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule majority_tb;\n\n    // Declare a 3-bit test vector to iterate through all input combinations.\n    reg [2:0] test_vector;\n    reg a, b, c;       // Inputs to the DUT.\n    wire out;          // DUT output.\n    reg expected;      // Expected result.\n    integer errors;    // Count the number of failed tests.\n    integer i;         // Loop variable.\n\n    // Instantiate the Device Under Test (DUT)\n    majority uut (\n        .a(a),\n        .b(b),\n        .c(c),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Loop through all 8 combinations of the 3-bit input.\n        // We'll assign a = test_vector[2], b = test_vector[1], c = test_vector[0]\n        for(i = 0; i < 8; i = i + 1) begin\n            test_vector = i;\n            a = test_vector[2];\n            b = test_vector[1];\n            c = test_vector[0];\n            #10; // Wait for the output to settle\n\n            // Compute expected majority: at least two 1's => output 1.\n            expected = (a & b) | (a & c) | (b & c);\n\n            // Display the test result in the desired format.\n            if(expected === out)\n                $display(\"    %b%b%b     |    %b     |   %b   |   Pass\", a, b, c, expected, out);\n            else begin\n                $display(\"    %b%b%b     |    %b     |   %b   |   Fail\", a, b, c, expected, out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if(errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n\n        $finish;\n    end\n\nendmodule\n"
        },
        {
            "module": "bin_to_gray",
            "Problem": "Implement a Verilog module that converts a 4-bit binary number to its 4-bit Gray code equivalent.",
            "Module header": "module bin_to_gray (\n    input [3:0] binary,\n    output [3:0] gray\n);\n    assign gray = binary ^ (binary >> 1);\nendmodule",
            "Testbench": "`timescale 1ns/1ps\nmodule bin_to_gray_tb;\n    reg [3:0] binary;          // Test input\n    wire [3:0] gray;           // Output from the design\n    \n    // Define arrays for test vectors and expected results.\n    reg [3:0] test_vectors[0:7];\n    reg [3:0] expected_values[0:7];\n    \n    integer i;\n    integer errors;\n    \n    // Instantiate the design under test.\n    bin_to_gray uut (\n        .binary(binary),\n        .gray(gray)\n    );\n    \n    initial begin\n        errors = 0;\n        \n        // Initialize test cases and corresponding expected Gray codes.\n        // For a 4-bit number, gray = binary ^ (binary >> 1)\n        // Example: binary = 4'b0010  -> 0010 >> 1 = 0001, 0010 XOR 0001 = 0011.\n        test_vectors[0] = 4'b0000;  expected_values[0] = 4'b0000; // 0000 -> 0000\n        test_vectors[1] = 4'b0001;  expected_values[1] = 4'b0001; // 0001 -> 0001\n        test_vectors[2] = 4'b0010;  expected_values[2] = 4'b0011; // 0010 -> 0011\n        test_vectors[3] = 4'b0011;  expected_values[3] = 4'b0010; // 0011 -> 0010\n        test_vectors[4] = 4'b0100;  expected_values[4] = 4'b0110; // 0100 -> 0110\n        test_vectors[5] = 4'b0101;  expected_values[5] = 4'b0111; // 0101 -> 0111\n        test_vectors[6] = 4'b0110;  expected_values[6] = 4'b0101; // 0110 -> 0101\n        test_vectors[7] = 4'b0111;  expected_values[7] = 4'b0100; // 0111 -> 0100\n        \n        // Display header\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Loop through test cases.\n        for (i = 0; i < 8; i = i + 1) begin\n            binary = test_vectors[i];\n            #10;  // Wait for the output to stabilize\n            if (gray === expected_values[i]) begin\n                $display(\"   %b     |   %b    |   %b   | PASS\", binary, expected_values[i], gray);\n            end else begin\n                $display(\"   %b     |   %b    |   %b   | FAIL\", binary, expected_values[i], gray);\n                errors = errors + 1;\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule"
        },
        {
            "module": "eq_comparator",
            "Problem": "Design a Verilog module that compares two 4-bit numbers and outputs 1 if they are equal, and 0 otherwise.",
            "Module header": "module eq_comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output equal\n);\n    assign equal = (a == b);\nendmodule",
            "Testbench": "`timescale 1ns/1ps\n\nmodule eq_comparator_tb;\n    reg  [3:0] a, b;      // Inputs for the Device Under Test (DUT)\n    wire equal;           // DUT output\n    reg  expected;        // Expected output (1 if a equals b, 0 otherwise)\n    integer errors;       // Counter for test failures\n    integer i, j;         // Loop variables for iterating through test cases\n\n    // Instantiate the DUT\n    eq_comparator uut (\n        .a(a),\n        .b(b),\n        .equal(equal)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Loop through all combinations of 4-bit numbers (0 to 15)\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                a = i;\n                b = j;\n                #10;  // Wait for the output to settle\n\n                // Expected output: 1 if a equals b, 0 otherwise.\n                expected = (a == b) ? 1'b1 : 1'b0;\n\n                // Check if the DUT's output matches the expected value.\n                if (equal === expected)\n                    $display(\"   %04b %04b  |    %b     |   %b   |   Pass\", a, b, expected, equal);\n                else begin\n                    $display(\"   %04b %04b  |    %b     |   %b   |   Fail\", a, b, expected, equal);\n                    errors = errors + 1;\n                end\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "decoder_2to4",
            "Problem": "Implement a 2-to-4 decoder module that converts a 2-bit input into a one-hot 4-bit output.",
            "Module header": "module decoder_2to4 (\n    input [1:0] in,\n    output [3:0] out\n);\n    assign out = 1 << in;\nendmodule",
            "Testbench": "`timescale 1ns/1ps\n\nmodule decoder_2to4_tb;\n    reg  [1:0] in;       // 2-bit input for the DUT.\n    wire [3:0] out;      // 4-bit output from the DUT.\n    reg  [3:0] expected; // Expected output.\n    integer errors;      // Count number of test failures.\n    integer i;           // Loop variable.\n\n    // Instantiate the Device Under Test (DUT)\n    decoder_2to4 uut (\n        .in(in),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Iterate through all possible 2-bit inputs (0 to 3)\n        for(i = 0; i < 4; i = i + 1) begin\n            in = i;\n            #10; // Wait for the output to settle\n\n            // Expected one-hot output: for input i, expected = (0001 << i)\n            expected = 4'b0001 << i;\n\n            // Compare the output and display the result.\n            if (out === expected)\n                $display(\"     %02b     |   %04b   |  %04b  |   Pass\", in, expected, out);\n            else begin\n                $display(\"     %02b     |   %04b   |  %04b  |   Fail\", in, expected, out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n            \n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "seven_segment_decoder",
            "Problem": "Design a Verilog module that converts a 4-bit binary input into a 7-segment display code for a common anode display.",
            "Module header": "module seven_segment_decoder (\n    input [3:0] digit,\n    output reg [6:0] segments\n);\n    always @(*) begin\n        case (digit)\n            4'd0: segments = 7'b1000000;\n            4'd1: segments = 7'b1111001;\n            4'd2: segments = 7'b0100100;\n            4'd3: segments = 7'b0110000;\n            4'd4: segments = 7'b0011001;\n            4'd5: segments = 7'b0010010;\n            4'd6: segments = 7'b0000010;\n            4'd7: segments = 7'b1111000;\n            4'd8: segments = 7'b0000000;\n            4'd9: segments = 7'b0010000;\n            default: segments = 7'b1111111;\n        endcase\n    end\nendmodule",
            "Testbench": "`timescale 1ns/1ps\n\nmodule seven_segment_decoder_tb;\n    reg  [3:0] digit;         // Input to the DUT\n    wire [6:0] segments;       // Output from the DUT\n    reg  [6:0] expected;       // Expected 7-segment code\n    integer errors;           // Count of errors\n    integer i;                // Loop variable\n\n    // Instantiate the DUT\n    seven_segment_decoder uut (\n        .digit(digit),\n        .segments(segments)\n    );\n\n    // Function to calculate expected 7-segment code based on the digit.\n    function [6:0] calc_expected;\n        input [3:0] d;\n        begin\n            case (d)\n                4'd0: calc_expected = 7'b1000000;\n                4'd1: calc_expected = 7'b1111001;\n                4'd2: calc_expected = 7'b0100100;\n                4'd3: calc_expected = 7'b0110000;\n                4'd4: calc_expected = 7'b0011001;\n                4'd5: calc_expected = 7'b0010010;\n                4'd6: calc_expected = 7'b0000010;\n                4'd7: calc_expected = 7'b1111000;\n                4'd8: calc_expected = 7'b0000000;\n                4'd9: calc_expected = 7'b0010000;\n                default: calc_expected = 7'b1111111;\n            endcase\n        end\n    endfunction\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Iterate through all 16 possible 4-bit input values\n        for(i = 0; i < 16; i = i + 1) begin\n            digit = i;\n            #10;  // Wait for the output to update\n            expected = calc_expected(digit);\n            if(segments === expected)\n                $display(\"    %04b    |  %07b  | %07b |   Pass\", digit, expected, segments);\n            else begin\n                $display(\"    %04b    |  %07b  | %07b |   Fail\", digit, expected, segments);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        \n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "priority_encoder",
            "Problem": "Design a 4-to-2 priority encoder module that outputs the binary code of the highest-order '1' in a 4-bit input. If no input is high, the output should be 0.",
            "Module header": "module priority_encoder (\n    input [3:0] in,\n    output reg [1:0] code\n);\n    always @(*) begin\n        if (in[3])\n            code = 2'b11;\n        else if (in[2])\n            code = 2'b10;\n        else if (in[1])\n            code = 2'b01;\n        else if (in[0])\n            code = 2'b00;\n        else\n            code = 2'b00;\n    end\nendmodule",
            "Testbench": "`timescale 1ns/1ps\n\nmodule priority_encoder_tb;\n    reg  [3:0] in;          // Input to the DUT\n    wire [1:0] code;        // Output from the DUT\n    reg  [1:0] expected;    // Expected output\n    integer errors;         // Count the number of test failures\n    integer i;              // Loop variable\n\n    // Instantiate the Device Under Test (DUT)\n    priority_encoder dut (\n        .in(in),\n        .code(code)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Iterate through all possible 4-bit input combinations (0 to 15)\n        for(i = 0; i < 16; i = i + 1) begin\n            in = i;\n            #10;  // Wait for output to settle\n\n            // Compute expected output based on the highest-order '1'\n            if (in[3])\n                expected = 2'b11;\n            else if (in[2])\n                expected = 2'b10;\n            else if (in[1])\n                expected = 2'b01;\n            else if (in[0])\n                expected = 2'b00;\n            else\n                expected = 2'b00;\n\n            // Check if the output matches the expected value and display the result\n            if (code === expected)\n                $display(\"   %04b    |    %02b    |  %02b   |   Pass\", in, expected, code);\n            else begin\n                $display(\"   %04b    |    %02b    |  %02b   |   Fail\", in, expected, code);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n\n        $finish;\n    end\nendmodule\n"
        }
    ],
    "Finite State Machines": [
        {
            "module": "fsm_3state",
            "Problem": "Implement a Verilog module for a 3-state FSM that toggles between states A, B, and C on each clock cycle.",
            "Module header": "module fsm_3state (\n    input clk, reset,\n    output [1:0] state\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule fsm_3state_tb;\n    reg clk, reset;\n    wire [1:0] state;\n    integer errors, cycle;\n    reg [1:0] expected_state;\n\n    // Instantiate the DUT (Device Under Test)\n    fsm_3state dut (\n        .clk(clk),\n        .reset(reset),\n        .state(state)\n    );\n\n    // Clock generation: 10 time-unit period.\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    initial begin\n        errors = 0;\n        \n        // Apply reset for one clock cycle.\n        reset = 1;\n        #10;          // Wait 10 time units.\n        reset = 0;   // Release reset.\n        \n        // Optionally, check the state immediately after reset:\n        #1; // small delay to allow state to settle\n        if (state !== 2'b00) begin\n            $display(\"Warning: state immediately after reset is not 00, got %02b\", state);\n        end\n        \n        // Display header for the testbench results.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // After reset, on the first rising edge, the design transitions to state B (2'b01)\n        expected_state = 2'b01;\n        \n        // Let the FSM run for several cycles.\n        // The expected transitions now are:\n        // Cycle 0: 2'b01, Cycle 1: 2'b10, Cycle 2: 2'b00, Cycle 3: 2'b01, etc.\n        for (cycle = 0; cycle < 9; cycle = cycle + 1) begin\n            @(posedge clk);\n            #1; // small delay for state to settle\n            if (state === expected_state)\n                $display(\"   Cycle %0d  |    %02b    |  %02b  |   Pass\", cycle, expected_state, state);\n            else begin\n                $display(\"   Cycle %0d  |    %02b    |  %02b  |   Fail\", cycle, expected_state, state);\n                errors = errors + 1;\n            end\n\n            // Update expected_state for the next cycle:\n            // B (01) -> C (10), C (10) -> A (00), A (00) -> B (01)\n            case(expected_state)\n                2'b01: expected_state = 2'b10;\n                2'b10: expected_state = 2'b00;\n                2'b00: expected_state = 2'b01;\n                default: expected_state = 2'b01;\n            endcase\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "traffic_light",
            "Problem": "Design a Verilog module for a traffic light controller FSM with states RED, YELLOW, and GREEN.",
            "Module header": "module traffic_light (\n    input clk, reset,\n    output [2:0] light\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule traffic_light_tb;\n    reg clk, reset;\n    wire [2:0] light;\n    integer errors, cycle;\n    reg [2:0] expected_light;\n\n    // Instantiate the DUT (Device Under Test)\n    traffic_light dut (\n        .clk(clk),\n        .reset(reset),\n        .light(light)\n    );\n\n    // Clock generation: 10 ns period (toggle every 5 ns)\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    initial begin\n        errors = 0;\n        \n        // Apply reset for 10 ns\n        reset = 1;\n        #10;\n        reset = 0;\n        #1;  // small delay for state to settle after reset\n\n        // (Optional) Check initial state before any clock edge.\n        // After reset, the FSM is in RED (3'b100).\n        if (light !== 3'b100)\n            $display(\"Warning: Initial state is not RED (expected 100), got %03b\", light);\n        \n        // Display header for the testbench results.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // After reset, the FSM is in RED.\n        // On the first rising edge the FSM transitions from RED to GREEN.\n        // Therefore, we expect the following sequence (sampled on each rising edge):\n        // Cycle 0: GREEN (3'b001)\n        // Cycle 1: YELLOW (3'b010)\n        // Cycle 2: RED    (3'b100)\n        // Cycle 3: GREEN  (3'b001)\n        // ... and so on.\n        expected_light = 3'b001; // set expected for Cycle 0\n\n        // Let the FSM run for 9 cycles.\n        for (cycle = 0; cycle < 9; cycle = cycle + 1) begin\n            @(posedge clk);\n            #1;  // small delay for the output to settle\n            \n            if (light === expected_light)\n                $display(\"   Cycle %0d  |   %03b   | %03b  |   Pass\", cycle, expected_light, light);\n            else begin\n                $display(\"   Cycle %0d  |   %03b   | %03b  |   Fail\", cycle, expected_light, light);\n                errors = errors + 1;\n            end\n            \n            // Update expected_light based on the FSM transitions:\n            // GREEN (001) -> YELLOW (010)\n            // YELLOW (010) -> RED (100)\n            // RED (100)    -> GREEN (001)\n            case(expected_light)\n                3'b001: expected_light = 3'b010;\n                3'b010: expected_light = 3'b100;\n                3'b100: expected_light = 3'b001;\n                default: expected_light = 3'b001;\n            endcase\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "elevator_controller",
            "Problem": "Design a Verilog module for a simple elevator controller FSM with states IDLE, MOVING_UP, and MOVING_DOWN. The elevator should transition between states based on the input signals `up_request` and `down_request`.",
            "Module header": "module elevator_controller (\n    input clk, reset,\n    input up_request, down_request,\n    output [1:0] state\n);",
            "Testbench": "`timescale 1ns/1ps\nmodule elevator_controller_tb;\n    reg clk, reset;\n    reg up_request, down_request;\n    wire [1:0] state;\n    \n    integer errors;\n    reg [1:0] expected;  // Expected state for each test\n\n    // Instantiate the Elevator Controller.\n    elevator_controller uut (\n        .clk(clk),\n        .reset(reset),\n        .up_request(up_request),\n        .down_request(down_request),\n        .state(state)\n    );\n    \n    // Clock generation: period = 10 time units.\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n    \n    initial begin\n        errors = 0;\n        \n        // Display header.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input           | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // --- Test 1: No Request ---\n        reset = 1;  // Assert reset.\n        up_request = 0;\n        down_request = 0;\n        #10;        // Hold reset for a couple cycles.\n        reset = 0;\n        @(posedge clk); #1;  // Wait for state update.\n        expected = 2'b00;     // IDLE\n        if (state === expected)\n            $display(\" No Request           |   %02b    |  %02b  |   Pass\", expected, state);\n        else begin\n            $display(\" No Request           |   %02b    |  %02b  |   Fail\", expected, state);\n            errors = errors + 1;\n        end\n\n        // --- Test 2: Up Request Only ---\n        up_request = 1;\n        down_request = 0;\n        @(posedge clk); #1;\n        expected = 2'b01;     // MOVING_UP\n        if (state === expected)\n            $display(\" Up Request           |   %02b    |  %02b  |   Pass\", expected, state);\n        else begin\n            $display(\" Up Request           |   %02b    |  %02b  |   Fail\", expected, state);\n            errors = errors + 1;\n        end\n\n        // --- Test 3: Down Request Only ---\n        up_request = 0;\n        down_request = 1;\n        @(posedge clk); #1;\n        expected = 2'b00;     // MOVING_DOWN\n        if (state === expected)\n            $display(\" Down Request         |   %02b    |  %02b  |   Pass\", expected, state);\n        else begin\n            $display(\" Down Request         |   %02b    |  %02b  |   Fail\", expected, state);\n            errors = errors + 1;\n        end\n\n        // --- Test 4: Both Requests Active ---\n        up_request = 1;\n        down_request = 1;\n        @(posedge clk); #1;\n        expected = 2'b01;     // Prioritize MOVING_UP when both are active.\n        if (state === expected)\n            $display(\" Both Requests        |   %02b    |  %02b  |   Pass\", expected, state);\n        else begin\n            $display(\" Both Requests        |   %02b    |  %02b  |   Fail\", expected, state);\n            errors = errors + 1;\n        end\n\n        // --- Test 5: Transition from MOVING_UP to IDLE ---\n        // Start with an up request then deassert it.\n        up_request = 1;\n        down_request = 0;\n        @(posedge clk); #1;   // Should be MOVING_UP.\n        expected = 2'b01;\n        if (state !== expected) begin\n            $display(\" Up Req, then Idle    |   %02b    |  %02b  |   Fail\", expected, state);\n            errors = errors + 1;\n        end\n        // Now deassert up_request.\n        up_request = 0;\n        @(posedge clk); #1;\n        expected = 2'b00;    // Should go back to IDLE.\n        if (state === expected)\n            $display(\" Idle after Up Req    |   %02b    |  %02b  |   Pass\", expected, state);\n        else begin\n            $display(\" Idle after Up Req    |   %02b    |  %02b  |   Fail\", expected, state);\n            errors = errors + 1;\n        end\n\n        // --- Test 6: Transition from MOVING_DOWN to IDLE ---\n        up_request = 0;\n        down_request = 1;\n        @(posedge clk); #1;   // Should be MOVING_DOWN.\n        expected = 2'b10;\n        if (state !== expected) begin\n            $display(\" Down Req, then Idle  |   %02b    |  %02b  |   Fail\", expected, state);\n            errors = errors + 1;\n        end\n        // Now deassert down_request.\n        down_request = 0;\n        @(posedge clk); #1;\n        expected = 2'b00;    // Should return to IDLE.\n        if (state === expected)\n            $display(\" Idle after Down Req  |   %02b    |  %02b  |   Pass\", expected, state);\n        else begin\n            $display(\" Idle after Down Req  |   %02b    |  %02b  |   Fail\", expected, state);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "vending_machine",
            "Problem": "Design a Verilog module for a vending machine FSM with states IDLE, COLLECTING_COINS, and DISPENSING_ITEM. The machine should transition based on the input signals `coin_inserted` and `item_selected`.",
            "Module header": "module vending_machine (\n    input clk, reset,\n    input coin_inserted, item_selected,\n    output [1:0] state\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule vending_machine_tb;\n    reg clk, reset;\n    reg coin_inserted, item_selected;\n    wire [1:0] state;\n\n    integer errors = 0;\n    reg [1:0] expected_state;\n\n    // Instantiate the vending machine FSM\n    vending_machine uut (\n        .clk(clk),\n        .reset(reset),\n        .coin_inserted(coin_inserted),\n        .item_selected(item_selected),\n        .state(state)\n    );\n\n    // Clock generation: 10 time-unit period.\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    initial begin\n        errors = 0;\n\n        // Reset the system\n        reset = 1;\n        coin_inserted = 0;\n        item_selected = 0;\n        #10;\n        reset = 0;\n\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Coin | Item | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test cases\n        run_test(1'b0, 1'b0, 2'b00); // IDLE state\n        run_test(1'b1, 1'b0, 2'b01); // COLLECTING_COINS state\n        run_test(1'b1, 1'b1, 2'b10); // DISPENSING_ITEM state\n        run_test(1'b0, 1'b0, 2'b00); // Return to IDLE\n        run_test(1'b1, 1'b0, 2'b01); // Insert coin again\n        run_test(1'b0, 1'b0, 2'b00); // Remove coin, should return to IDLE\n\n        $display(\"=====================================\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\n\n    // Task to verify expected state\n    task run_test;\n        input reg test_coin_inserted, test_item_selected;\n        input [1:0] exp_state;\n        begin\n            coin_inserted = test_coin_inserted;\n            item_selected = test_item_selected;\n            expected_state = exp_state;\n            #10; // Wait for state transition\n\n            if (state === expected_state) begin\n                $display(\"  %b   |  %b   |    %02b     |   %02b   |  PASS\", coin_inserted, item_selected, expected_state, state);\n            end else begin\n                $display(\"  %b   |  %b   |    %02b     |   %02b   |  FAIL\", coin_inserted, item_selected, expected_state, state);\n                errors = errors + 1;\n            end\n        end\n    endtask\n\nendmodule\n"
        }
    ],
    "Mathematical Functions": [
        {
            "module": "int_sqrt",
            "Problem": "Write a Verilog module to compute the integer square root of x, where x is a signed 16-bit integer and the output y is a signed 8-bit integer.",
            "Module header": "module int_sqrt (\n    input signed [15:0] in_0,\n    output signed [7:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule int_sqrt_tb;\n    // DUT I/O\n    reg  signed [15:0] in_0;\n    wire signed [7:0] out;\n    \n    // Testbench variables\n    integer errors, i;\n    \n    // Define arrays of test cases.\n    // (Note: This syntax is supported in Verilog-2001/SystemVerilog simulators.)\n    reg signed [15:0] test_inputs [0:12];\n    reg signed [7:0]  expected_outputs [0:12];\n\n    // Instantiate the Device Under Test (DUT)\n    int_sqrt dut (\n        .in_0(in_0),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        \n        // Initialize test cases:\n        //   For negative input, expect 0.\n        //   Otherwise, the expected output is the floor(sqrt(x)).\n        test_inputs[0] = -1;     expected_outputs[0] = 0;\n        test_inputs[1] = 0;      expected_outputs[1] = 0;\n        test_inputs[2] = 1;      expected_outputs[2] = 1;\n        test_inputs[3] = 2;      expected_outputs[3] = 1;\n        test_inputs[4] = 3;      expected_outputs[4] = 1;\n        test_inputs[5] = 4;      expected_outputs[5] = 2;\n        test_inputs[6] = 15;     expected_outputs[6] = 3; // 3*3=9, 4*4=16 > 15\n        test_inputs[7] = 16;     expected_outputs[7] = 4;\n        test_inputs[8] = 17;     expected_outputs[8] = 4;\n        test_inputs[9] = 100;    expected_outputs[9] = 10; \n        test_inputs[10] = 1024;  expected_outputs[10] = 32; // 32*32 = 1024\n        test_inputs[11] = 16129; expected_outputs[11] = 127; // 127*127 = 16129\n        test_inputs[12] = 16130; expected_outputs[12] = 127; // exceeds 16129 -> still 127\n\n        // Display header for the testbench results.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Iterate through the test cases.\n        for (i = 0; i < 13; i = i + 1) begin\n            in_0 = test_inputs[i];\n            #10; // Allow combinational logic to settle.\n            if (out === expected_outputs[i])\n                $display(\"   %6d   |   %3d    |  %3d   |   Pass\", test_inputs[i], expected_outputs[i], out);\n            else begin\n                $display(\"   %6d   |   %3d    |  %3d   |   Fail\", test_inputs[i], expected_outputs[i], out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "fibonacci",
            "Problem": "Implement a Verilog module to generate the Fibonacci sequence up to n terms, where n is a signed 8-bit integer and each Fibonacci number is a signed 16-bit integer.",
            "Module header": "module fibonacci (\n    input signed [7:0] in_0,\n    output signed [15:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule fibonacci_tb;\n    reg signed [7:0] in_0;           // Test input: n (number of terms)\n    wire signed [15:0] out;          // Output: Fibonacci number F(n)\n    reg signed [15:0] expected;      // Expected Fibonacci result\n    integer errors;                // Error counter\n\n    // Instantiate the DUT (Device Under Test)\n    fibonacci dut (\n        .in_0(in_0),\n        .out(out)\n    );\n\n    // Function to calculate the expected Fibonacci number using an iterative algorithm.\n    // Note: This function is written in plain Verilog.\n    function signed [15:0] fib;\n        input signed [7:0] n;\n        integer j;\n        reg signed [15:0] a, b, temp;\n        begin\n            if (n < 0)\n                fib = 0;\n            else if (n == 0)\n                fib = 0;\n            else if (n == 1)\n                fib = 1;\n            else begin\n                a = 0;\n                b = 1;\n                for (j = 2; j <= n; j = j + 1) begin\n                    temp = a + b;\n                    a = b;\n                    b = temp;\n                end\n                fib = b;\n            end\n        end\n    endfunction\n\n    initial begin\n        errors = 0;\n        \n        // Display header for the test results.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Test case 1: n = -1 (negative input, expected output 0)\n        in_0 = -1;  #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test case 2: n = 0\n        in_0 = 0;   #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test case 3: n = 1\n        in_0 = 1;   #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test case 4: n = 2\n        in_0 = 2;   #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test case 5: n = 3\n        in_0 = 3;   #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test case 6: n = 4\n        in_0 = 4;   #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test case 7: n = 5\n        in_0 = 5;   #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test case 8: n = 6\n        in_0 = 6;   #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test case 9: n = 10\n        in_0 = 10;  #10;\n        expected = fib(in_0);\n        if (out === expected)\n            $display(\"    %4d    |   %5d  | %5d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"    %4d    |   %5d  | %5d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "mod_exp",
            "Problem": "Write a Verilog module that computes modular exponentiation y = a^b mod m, where a, b, and m are signed 8-bit integers, and y is a signed 8-bit integer.",
            "Module header": "module mod_exp (\n    input signed [7:0] in_0,\n    input signed [7:0] in_1,\n    input signed [7:0] in_2,\n    output signed [7:0] out\n);",
            "Testbench": "// mod_exp_tb.v\n// Testbench for the mod_exp module. This testbench applies several test cases\n// and displays the results in a table indicating Pass/Fail for each test.\n\n`timescale 1ns/1ps\n\nmodule mod_exp_tb;\n    reg signed [7:0] a, b, m;    // Test inputs (a, b, m)\n    wire signed [7:0] y;         // Output: y = a^b mod m\n    reg signed [7:0] expected;   // Expected result for each test case\n    integer errors;\n    \n    // Instantiate the design under test (DUT)\n    mod_exp dut (\n        .in_0(a),\n        .in_1(b),\n        .in_2(m),\n        .out(y)\n    );\n\n    initial begin\n        errors = 0;\n        \n        // Display header.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input           | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test Case 1: 2^3 mod 5 = 8 mod 5 = 3.\n        a = 2;  b = 3;  m = 5;\n        #10;  // Wait for the combinational logic to settle.\n        expected = 3;\n        $display(\" a=%0d, b=%0d, m=%0d |   %3d   |   %3d  | %s\", \n                 a, b, m, expected, y, (y === expected ? \"Pass\" : \"Fail\"));\n        if (y !== expected) errors = errors + 1;\n        \n        // Test Case 2: 3^4 mod 7 = 81 mod 7 = 4.\n        a = 3;  b = 4;  m = 7;\n        #10;\n        expected = 4;\n        $display(\" a=%0d, b=%0d, m=%0d |   %3d   |   %3d  | %s\", \n                 a, b, m, expected, y, (y === expected ? \"Pass\" : \"Fail\"));\n        if (y !== expected) errors = errors + 1;\n        \n        // Test Case 3: 2^0 mod 5 = 1 mod 5 = 1.\n        a = 2;  b = 0;  m = 5;\n        #10;\n        expected = 1;\n        $display(\" a=%0d, b=%0d, m=%0d |   %3d   |   %3d  | %s\", \n                 a, b, m, expected, y, (y === expected ? \"Pass\" : \"Fail\"));\n        if (y !== expected) errors = errors + 1;\n        \n        // Test Case 4: 0^5 mod 7 = 0.\n        a = 0;  b = 5;  m = 7;\n        #10;\n        expected = 0;\n        $display(\" a=%0d, b=%0d, m=%0d |   %3d   |   %3d  | %s\", \n                 a, b, m, expected, y, (y === expected ? \"Pass\" : \"Fail\"));\n        if (y !== expected) errors = errors + 1;\n        \n        // Test Case 5: 10^3 mod 6 = 1000 mod 6 = 4.\n        a = 10;  b = 3;  m = 6;\n        #10;\n        expected = 4;\n        $display(\" a=%0d, b=%0d, m=%0d |   %3d   |   %3d  | %s\", \n                 a, b, m, expected, y, (y === expected ? \"Pass\" : \"Fail\"));\n        if (y !== expected) errors = errors + 1;\n        \n        // Test Case 6: Negative base: (-2)^3 mod 5.\n        // In Verilog, -8 % 5 yields -3.\n        a = -2;  b = 3;  m = 5;\n        #10;\n        expected = -3;\n        $display(\" a=%0d, b=%0d, m=%0d |   %3d   |   %3d  | %s\", \n                 a, b, m, expected, y, (y === expected ? \"Pass\" : \"Fail\"));\n        if (y !== expected) errors = errors + 1;\n        \n        // Test Case 7: Modulus is zero; our module returns 0.\n        a = 5;  b = 3;  m = 0;\n        #10;\n        expected = 0;\n        $display(\" a=%0d, b=%0d, m=%0d |   %3d   |   %3d  | %s\", \n                 a, b, m, expected, y, (y === expected ? \"Pass\" : \"Fail\"));\n        if (y !== expected) errors = errors + 1;\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\n\nendmodule\n"
        },
        {
            "module": "power",
            "Problem": "Write a Verilog module that computes y = a^b, where a is a signed 8-bit integer, b is a signed 4-bit integer, and y is a signed 16-bit integer.",
            "Module header": "module power (\n    input signed [7:0] in_0,\n    input signed [3:0] in_1,\n    output signed [15:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule power_tb;\n    reg  signed [7:0] a;       // Base input for the DUT\n    reg  signed [3:0] b;       // Exponent input for the DUT\n    wire signed [15:0] y;      // DUT output\n    reg  signed [15:0] expected; // Expected result for each test case\n    integer errors;\n    \n    // Instantiate the DUT\n    power dut (\n        .in_0(a),\n        .in_1(b),\n        .out(y)\n    );\n    \n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input (a, b) | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Test Case 1: a = 2, b = 3 --> 2^3 = 8\n        a = 8'd2; b = 4'd3; expected = 16'd8; #10;\n        if (y === expected)\n            $display(\"    %3d, %3d      |   %6d | %6d |   Pass\", a, b, expected, y);\n        else begin\n            $display(\"    %3d, %3d      |   %6d | %6d |   Fail\", a, b, expected, y);\n            errors = errors + 1;\n        end\n        \n        // Test Case 2: a = 3, b = 2 --> 3^2 = 9\n        a = 8'd3; b = 4'd2; expected = 16'd9; #10;\n        if (y === expected)\n            $display(\"    %3d, %3d      |   %6d | %6d |   Pass\", a, b, expected, y);\n        else begin\n            $display(\"    %3d, %3d      |   %6d | %6d |   Fail\", a, b, expected, y);\n            errors = errors + 1;\n        end\n        \n        // Test Case 3: a = -2, b = 3 --> (-2)^3 = -8\n        a = -8'd2; b = 4'd3; expected = -16'd8; #10;\n        if (y === expected)\n            $display(\"    %3d, %3d      |   %6d | %6d |   Pass\", a, b, expected, y);\n        else begin\n            $display(\"    %3d, %3d      |   %6d | %6d |   Fail\", a, b, expected, y);\n            errors = errors + 1;\n        end\n        \n        // Test Case 4: a = 2, b = 0 --> 2^0 = 1\n        a = 8'd2; b = 4'd0; expected = 16'd1; #10;\n        if (y === expected)\n            $display(\"    %3d, %3d      |   %6d | %6d |   Pass\", a, b, expected, y);\n        else begin\n            $display(\"    %3d, %3d      |   %6d | %6d |   Fail\", a, b, expected, y);\n            errors = errors + 1;\n        end\n        \n        // Test Case 5: a = -3, b = 4 --> (-3)^4 = 81\n        a = -8'd3; b = 4'd4; expected = 16'd81; #10;\n        if (y === expected)\n            $display(\"    %3d, %3d      |   %6d | %6d |   Pass\", a, b, expected, y);\n        else begin\n            $display(\"    %3d, %3d      |   %6d | %6d |   Fail\", a, b, expected, y);\n            errors = errors + 1;\n        end\n        \n        // Test Case 6: a = 0, b = 5 --> 0^5 = 0\n        a = 8'd0; b = 4'd5; expected = 16'd0; #10;\n        if (y === expected)\n            $display(\"    %3d, %3d      |   %6d | %6d |   Pass\", a, b, expected, y);\n        else begin\n            $display(\"    %3d, %3d      |   %6d | %6d |   Fail\", a, b, expected, y);\n            errors = errors + 1;\n        end\n        \n        // Test Case 7: a = 2, b = -1 --> Negative exponent: defined to yield 0\n        a = 8'd2; b = -4'd1; expected = 16'd0; #10;\n        if (y === expected)\n            $display(\"    %3d, %3d      |   %6d | %6d |   Pass\", a, b, expected, y);\n        else begin\n            $display(\"    %3d, %3d      |   %6d | %6d |   Fail\", a, b, expected, y);\n            errors = errors + 1;\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "log2_int",
            "Problem": "Write a Verilog module to compute the integer logarithm base 2 of x, where x is a signed 16-bit integer, and the output y is a signed 8-bit integer. If the input is smaller than 0, then set the output to 0.",
            "Module header": "module log2_int (\n    input signed [15:0] in_0,\n    output signed [7:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule log2_int_tb;\n    reg signed [15:0] in_0;\n    wire signed [7:0] out;\n    integer errors, i;\n    reg signed [7:0] expected;\n    \n    // Instantiate the DUT.\n    log2_int dut (\n        .in_0(in_0),\n        .out(out)\n    );\n    \n    // Function to compute the expected integer log base 2.\n    // This function scans the input from bit 15 to 0 and returns the index\n    // of the first (most significant) '1'. (If x <= 0, it returns 0.)\n    function signed [7:0] calc_log2;\n        input signed [15:0] x;\n        integer j;\n        reg found;\n        begin\n            if (x <= 0)\n                calc_log2 = 0;\n            else begin\n                found = 0;\n                calc_log2 = 0;\n                for (j = 15; j >= 0; j = j - 1) begin\n                    if (!found && (x[j] == 1'b1)) begin\n                        calc_log2 = j;\n                        found = 1;\n                    end\n                end\n            end\n        end\n    endfunction\n    \n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Apply a set of test vectors.\n        // We test 13 cases: 0, 1, 2, 3, 4, 7, 8, 15, 16, 1023, 1024, -1, -100.\n        for (i = 0; i < 13; i = i + 1) begin\n            case (i)\n                0: in_0 = 16'd0;\n                1: in_0 = 16'd1;\n                2: in_0 = 16'd2;\n                3: in_0 = 16'd3;\n                4: in_0 = 16'd4;\n                5: in_0 = 16'd7;\n                6: in_0 = 16'd8;\n                7: in_0 = 16'd15;\n                8: in_0 = 16'd16;\n                9: in_0 = 16'd1023;\n                10: in_0 = 16'd1024;\n                11: in_0 = -16'sd1;\n                12: in_0 = -16'sd100;\n                default: in_0 = 16'd0;\n            endcase\n            #10;  // Allow combinational logic to settle.\n            expected = calc_log2(in_0);\n            \n            if (out === expected)\n                $display(\"   %6d   |    %3d   |  %3d   |   Pass\", in_0, expected, out);\n            else begin\n                $display(\"   %6d   |    %3d   |  %3d   |   Fail\", in_0, expected, out);\n                errors = errors + 1;\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        \n        $finish;\n    end\nendmodule\n"
        }
    ],
    "Basic Arithmetic Operations": [
        {
            "module": "add_8bit",
            "Problem": "Implement a Verilog module that computes the sum of two 8-bit signed integers. The output should be a 9-bit signed integer to handle overflow.",
            "Module header": "module add_8bit (\n    input signed [7:0] a, b,\n    output signed [8:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule add_8bit_tb;\n    reg   signed [7:0] a, b;           // Test inputs (signed 8-bit)\n    wire  signed [8:0] out;            // DUT output (signed 9-bit)\n    integer errors;                   // Count of errors\n    reg   signed [8:0] expected;       // Expected output\n\n    // Instantiate the device under test (DUT)\n    add_8bit dut (\n        .a(a),\n        .b(b),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input           | Expected | Output   | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test Case 1: 10 + 20 = 30\n        a = 8'd10; b = 8'd20; \n        #10; \n        expected = 9'd30;\n        if (out === expected)\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Pass\", a, b, expected, out);\n        else begin\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Fail\", a, b, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 2: -15 + 10 = -5\n        a = -8'd15; b = 8'd10; \n        #10; \n        expected = -9'd5;\n        if (out === expected)\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Pass\", a, b, expected, out);\n        else begin\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Fail\", a, b, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 3: 127 + 1 = 128 (Positive overflow edge)\n        a = 8'd127; b = 8'd1; \n        #10; \n        expected = 9'd128;\n        if (out === expected)\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Pass\", a, b, expected, out);\n        else begin\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Fail\", a, b, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 4: -128 + (-1) = -129 (Negative overflow edge)\n        a = -8'd128; b = -8'd1; \n        #10; \n        expected = -9'd129;\n        if (out === expected)\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Pass\", a, b, expected, out);\n        else begin\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Fail\", a, b, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 5: -50 + (-70) = -120\n        a = -8'd50; b = -8'd70; \n        #10; \n        expected = -9'd120;\n        if (out === expected)\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Pass\", a, b, expected, out);\n        else begin\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Fail\", a, b, expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 6: 50 + (-30) = 20\n        a = 8'd50; b = -8'd30; \n        #10; \n        expected = 9'd20;\n        if (out === expected)\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Pass\", a, b, expected, out);\n        else begin\n            $display(\"  %3d + %3d         |   %3d    |   %3d   |   Fail\", a, b, expected, out);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "mult_4bit",
            "Problem": "Design a Verilog module that multiplies two 4-bit unsigned integers and produces an 8-bit unsigned output.",
            "Module header": "module mult_4bit (\n    input [3:0] a, b,\n    output [7:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule mult_4bit_tb;\n    reg  [3:0] a, b;         // DUT inputs.\n    wire [7:0] out;          // DUT output.\n    reg  [7:0] expected;     // Expected multiplication result.\n    integer    errors, i, j;  // Counters.\n\n    // Instantiate the DUT.\n    mult_4bit uut (\n        .a(a),\n        .b(b),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        \n        // Display header for testbench results.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input         | Expected  |  Output   | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Iterate through all 16x16 combinations.\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                a = i;\n                b = j;\n                #10;  // Wait for the output to settle.\n                \n                // Calculate the expected result.\n                expected = i * j;\n                \n                // Compare DUT output with expected value.\n                if (out === expected)\n                    $display(\" a=%04b, b=%04b | %08b | %08b |   Pass\", a, b, expected, out);\n                else begin\n                    $display(\" a=%04b, b=%04b | %08b | %08b |   Fail\", a, b, expected, out);\n                    errors = errors + 1;\n                end\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "abs_diff",
            "Problem": "Write a Verilog module that computes the absolute difference between two 8-bit signed integers.",
            "Module header": "module abs_diff (\n    input signed [7:0] a, b,\n    output [7:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule abs_diff_tb;\n    // Declare testbench signals.\n    // Use 'reg signed' for a and b so that the signed arithmetic is preserved.\n    reg   signed [7:0] a, b;\n    wire        [7:0] out;\n    reg         [7:0] expected;\n    integer errors;\n\n    // Instantiate the DUT (Device Under Test)\n    abs_diff uut (\n        .a(a),\n        .b(b),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input (a, b)       | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------------------------\");\n\n        // Test Case 1: a = 0, b = 0 -> |0 - 0| = 0\n        a =  0; b =  0;\n        expected = 0;\n        #10;\n        if (out === expected)\n            $display(\"  (  0,   0)           |   %03d   |  %03d  |   Pass\", expected, out);\n        else begin\n            $display(\"  (  0,   0)           |   %03d   |  %03d  |   Fail\", expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 2: a = 10, b = 3 -> |10 - 3| = 7\n        a =  10; b =  3;\n        expected = 7;\n        #10;\n        if (out === expected)\n            $display(\"  ( 10,   3)           |   %03d   |  %03d  |   Pass\", expected, out);\n        else begin\n            $display(\"  ( 10,   3)           |   %03d   |  %03d  |   Fail\", expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 3: a = 3, b = 10 -> |3 - 10| = 7\n        a =   3; b = 10;\n        expected = 7;\n        #10;\n        if (out === expected)\n            $display(\"  (  3,  10)           |   %03d   |  %03d  |   Pass\", expected, out);\n        else begin\n            $display(\"  (  3,  10)           |   %03d   |  %03d  |   Fail\", expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 4: a = -5, b = 3 -> | -5 - 3| = 8\n        a = -8'sd5; b = 8'sd3;\n        expected = 8;\n        #10;\n        if (out === expected)\n            $display(\"  (-5,   3)            |   %03d   |  %03d  |   Pass\", expected, out);\n        else begin\n            $display(\"  (-5,   3)            |   %03d   |  %03d  |   Fail\", expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 5: a = -100, b = 100 -> | -100 - 100| = 200\n        a = -8'sd100; b = 8'sd100;\n        expected = 200;\n        #10;\n        if (out === expected)\n            $display(\"  (-100, 100)          |   %03d   |  %03d  |   Pass\", expected, out);\n        else begin\n            $display(\"  (-100, 100)          |   %03d   |  %03d  |   Fail\", expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 6: a = 127, b = -128 -> |127 - (-128)| = 255\n        a = 127; b = -128;\n        expected = 255;\n        #10;\n        if (out === expected)\n            $display(\"  (127, -128)          |   %03d   |  %03d  |   Pass\", expected, out);\n        else begin\n            $display(\"  (127, -128)          |   %03d   |  %03d  |   Fail\", expected, out);\n            errors = errors + 1;\n        end\n\n        // Test Case 7: a = -128, b = 127 -> |-128 - 127| = 255\n        a = -128; b = 127;\n        expected = 255;\n        #10;\n        if (out === expected)\n            $display(\"  (-128, 127)          |   %03d   |  %03d  |   Pass\", expected, out);\n        else begin\n            $display(\"  (-128, 127)          |   %03d   |  %03d  |   Fail\", expected, out);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\n\nendmodule\n"
        },
        {
            "module": "modulo_op",
            "Problem": "Write a Verilog module that computes the modulo of two 8-bit unsigned integers. The module should output the remainder after dividing a by b. Assume b is non-zero.",
            "Module header": "module modulo_op (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] remainder\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule modulo_op_tb;\n    reg  [7:0] a, b;         // Testbench drivers for inputs.\n    wire [7:0] remainder;      // DUT output.\n    reg  [7:0] expected;       // Expected remainder.\n    integer errors;           // Counter for errors.\n\n    // Instantiate the DUT.\n    modulo_op uut (\n        .a(a),\n        .b(b),\n        .remainder(remainder)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input        | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test Case 1: a = 10, b = 3   => 10 % 3 = 1\n        a = 8'd10; b = 8'd3;\n        #10;\n        expected = 8'd10 % 8'd3;\n        if (remainder === expected)\n            $display(\"   a=10, b=3     |    %03d   |  %03d  |   Pass\", expected, remainder);\n        else begin\n            $display(\"   a=10, b=3     |    %03d   |  %03d  |   Fail\", expected, remainder);\n            errors = errors + 1;\n        end\n\n        // Test Case 2: a = 255, b = 2   => 255 % 2 = 1\n        a = 8'd255; b = 8'd2;\n        #10;\n        expected = 8'd255 % 8'd2;\n        if (remainder === expected)\n            $display(\"  a=255, b=2     |    %03d   |  %03d  |   Pass\", expected, remainder);\n        else begin\n            $display(\"  a=255, b=2     |    %03d   |  %03d  |   Fail\", expected, remainder);\n            errors = errors + 1;\n        end\n\n        // Test Case 3: a = 100, b = 7   => 100 % 7 = 2 (since 7*14=98)\n        a = 8'd100; b = 8'd7;\n        #10;\n        expected = 8'd100 % 8'd7;\n        if (remainder === expected)\n            $display(\"  a=100, b=7     |    %03d   |  %03d  |   Pass\", expected, remainder);\n        else begin\n            $display(\"  a=100, b=7     |    %03d   |  %03d  |   Fail\", expected, remainder);\n            errors = errors + 1;\n        end\n\n        // Test Case 4: a = 0, b = 5     => 0 % 5 = 0\n        a = 8'd0; b = 8'd5;\n        #10;\n        expected = 8'd0 % 8'd5;\n        if (remainder === expected)\n            $display(\"   a=0, b=5      |    %03d   |  %03d  |   Pass\", expected, remainder);\n        else begin\n            $display(\"   a=0, b=5      |    %03d   |  %03d  |   Fail\", expected, remainder);\n            errors = errors + 1;\n        end\n\n        // Test Case 5: a = 13, b = 4    => 13 % 4 = 1\n        a = 8'd13; b = 8'd4;\n        #10;\n        expected = 8'd13 % 8'd4;\n        if (remainder === expected)\n            $display(\"  a=13, b=4      |    %03d   |  %03d  |   Pass\", expected, remainder);\n        else begin\n            $display(\"  a=13, b=4      |    %03d   |  %03d  |   Fail\", expected, remainder);\n            errors = errors + 1;\n        end\n\n        // Test Case 6: a = 50, b = 6    => 50 % 6 = 2\n        a = 8'd50; b = 8'd6;\n        #10;\n        expected = 8'd50 % 8'd6;\n        if (remainder === expected)\n            $display(\"  a=50, b=6      |    %03d   |  %03d  |   Pass\", expected, remainder);\n        else begin\n            $display(\"  a=50, b=6      |    %03d   |  %03d  |   Fail\", expected, remainder);\n            errors = errors + 1;\n        end\n\n        // Test Case 7: a = 200, b = 10  => 200 % 10 = 0\n        a = 8'd200; b = 8'd10;\n        #10;\n        expected = 8'd200 % 8'd10;\n        if (remainder === expected)\n            $display(\" a=200, b=10     |    %03d   |  %03d  |   Pass\", expected, remainder);\n        else begin\n            $display(\" a=200, b=10     |    %03d   |  %03d  |   Fail\", expected, remainder);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "subtract_8bit",
            "Problem": "Implement a Verilog module that subtracts one 8-bit signed integer from another. The output should be a 9-bit signed integer to handle underflow/overflow.",
            "Module header": "module subtract_8bit (\n    input signed [7:0] a, b,\n    output signed [8:0] diff\n);",
            "Testbench": "// subtract_8bit_tb.v\n`timescale 1ns/1ps\n\nmodule subtract_8bit_tb;\n    reg  signed [7:0] a, b;         // Test inputs\n    wire signed [8:0] diff;         // DUT output\n    reg  signed [8:0] expected;     // Expected result\n    integer errors;                 // Error counter\n\n    // Instantiate the design under test (DUT)\n    subtract_8bit dut (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input         | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test Case 1: 10 - 3 = 7\n        a = 8'sd10; b = 8'sd3;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\" 10 -  3          |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\" 10 -  3          |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        // Test Case 2: -10 - 5 = -15\n        a = -8'sd10; b = 8'sd5;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\"-10 -  5          |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\"-10 -  5          |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        // Test Case 3: 127 - (-128) = 255\n        a = 8'sd127; b = -8'sd128;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\"127 - -128        |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\"127 - -128        |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        // Test Case 4: -128 - 127 = -255\n        a = -8'sd128; b = 8'sd127;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\"-128 - 127        |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\"-128 - 127        |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        // Test Case 5: 0 - 0 = 0\n        a = 8'sd0; b = 8'sd0;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\"  0 -  0          |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\"  0 -  0          |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        // Test Case 6: 50 - (-50) = 100\n        a = 8'sd50; b = -8'sd50;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\" 50 - -50         |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\" 50 - -50         |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        // Test Case 7: -50 - 50 = -100\n        a = -8'sd50; b = 8'sd50;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\"-50 - 50          |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\"-50 - 50          |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        // Test Case 8: -128 - (-128) = 0\n        a = -8'sd128; b = -8'sd128;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\"-128 - -128       |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\"-128 - -128       |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        // Test Case 9: 127 - 127 = 0\n        a = 8'sd127; b = 8'sd127;\n        #10;\n        expected = a - b;\n        if(diff === expected)\n            $display(\"127 - 127         |   %4d   |  %4d  |   Pass\", expected, diff);\n        else begin\n            $display(\"127 - 127         |   %4d   |  %4d  |   Fail\", expected, diff);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        }
    ],
    "Bitwise and Logical Operations": [
        {
            "module": "bitwise_ops",
            "Problem": "Write a Verilog module that computes the bitwise AND, OR, and XOR of two 8-bit inputs. The module should output three 8-bit results corresponding to each operation.",
            "Module header": "module bitwise_ops (\n    input [7:0] a, b,\n    output [7:0] and_out,\n    output [7:0] or_out,\n    output [7:0] xor_out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule bitwise_ops_tb;\n    reg  [7:0] a, b;\n    wire [7:0] and_out, or_out, xor_out;\n    integer i, errors;\n    reg [7:0] expected_and, expected_or, expected_xor;\n\n    // Test vectors stored in two arrays.\n    // (Verilog-2001 supports one-dimensional arrays for testbenches.)\n    reg [7:0] test_a [0:4];\n    reg [7:0] test_b [0:4];\n\n    // Instantiate the Device Under Test (DUT)\n    bitwise_ops dut (\n        .a(a),\n        .b(b),\n        .and_out(and_out),\n        .or_out(or_out),\n        .xor_out(xor_out)\n    );\n\n    // Initialize the test vectors.\n    initial begin\n        test_a[0] = 8'hAA;  test_b[0] = 8'h55;  // 0xAA = 10101010, 0x55 = 01010101\n                                             // Expected: and = 0x00, or = 0xFF, xor = 0xFF\n        test_a[1] = 8'hFF;  test_b[1] = 8'hF0;  // Expected: and = 0xF0, or = 0xFF, xor = 0x0F\n        test_a[2] = 8'h00;  test_b[2] = 8'h0F;  // Expected: and = 0x00, or = 0x0F, xor = 0x0F\n        test_a[3] = 8'hC3;  test_b[3] = 8'h3C;  // C3 = 11000011, 3C = 00111100\n                                             // Expected: and = 8'h00, or = 8'hFF, xor = 8'hFF\n        test_a[4] = 8'hF0;  test_b[4] = 8'h0F;  // Expected: and = 8'h00, or = 8'hFF, xor = 8'hFF\n    end\n\n    // Testbench main process.\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  |       Expected       |        Output        | Pass/Fail \");\n        $display(\"             | (AND / OR / XOR)     | (AND / OR / XOR)     |           \");\n        $display(\"-------------------------------------\");\n\n        // Loop through the test cases.\n        for (i = 0; i < 5; i = i + 1) begin\n            a = test_a[i];\n            b = test_b[i];\n            #10;  // Wait for outputs to settle.\n            \n            // Compute the expected values.\n            expected_and = a & b;\n            expected_or  = a | b;\n            expected_xor = a ^ b;\n            \n            // Check if all three outputs match the expected values.\n            if ((and_out === expected_and) && (or_out === expected_or) &&\n                (xor_out === expected_xor))\n                $display(\"   %02h, %02h  |   %02h / %02h / %02h   |   %02h / %02h / %02h   |   Pass\",\n                         a, b, expected_and, expected_or, expected_xor,\n                         and_out, or_out, xor_out);\n            else begin\n                $display(\"   %02h, %02h  |   %02h / %02h / %02h   |   %02h / %02h / %02h   |   Fail\",\n                         a, b, expected_and, expected_or, expected_xor,\n                         and_out, or_out, xor_out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\n\nendmodule\n"
        },
        {
            "module": "left_shift",
            "Problem": "Implement a Verilog module that performs a logical left shift on an 8-bit input by a variable shift amount.",
            "Module header": "module left_shift (\n    input [7:0] in,\n    input [2:0] shift,\n    output [7:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule left_shift_tb;\n    reg  [7:0] in;\n    reg  [2:0] shift;\n    wire [7:0] out;\n    integer errors, i;\n    \n    // Define the number of test cases.\n    parameter NUM_TESTS = 8;\n    \n    // Test vectors defined as arrays.\n    reg [7:0] test_in   [0:NUM_TESTS-1];\n    reg [2:0] test_shift[0:NUM_TESTS-1];\n    reg [7:0] test_expected[0:NUM_TESTS-1];\n    \n    // Instantiate the DUT.\n    left_shift dut (\n        .in(in),\n        .shift(shift),\n        .out(out)\n    );\n    \n    initial begin\n        // Initialize test vectors.\n        test_in[0]    = 8'b00000000; test_shift[0] = 3'b000; test_expected[0] = 8'b00000000;\n        test_in[1]    = 8'b00000001; test_shift[1] = 3'b001; test_expected[1] = 8'b00000010;\n        test_in[2]    = 8'b00000001; test_shift[2] = 3'b010; test_expected[2] = 8'b00000100;\n        test_in[3]    = 8'b00000101; test_shift[3] = 3'b011; test_expected[3] = 8'b00101000;\n        test_in[4]    = 8'b11110000; test_shift[4] = 3'b001; test_expected[4] = 8'b11100000;\n        test_in[5]    = 8'b10101010; test_shift[5] = 3'b010; test_expected[5] = 8'b10101000;\n        test_in[6]    = 8'b01010101; test_shift[6] = 3'b100; test_expected[6] = 8'b01010000;\n        test_in[7]    = 8'b11111111; test_shift[7] = 3'b111; test_expected[7] = 8'b10000000;\n        \n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input (in,shift)  | Expected  |  Output   | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Loop through each test case.\n        for (i = 0; i < NUM_TESTS; i = i + 1) begin\n            in = test_in[i];\n            shift = test_shift[i];\n            #10; // Allow time for the output to settle.\n            \n            // Check if the output matches the expected value.\n            if (out === test_expected[i])\n                $display(\"    %08b, %03b      |  %08b  |  %08b  |   Pass\", in, shift, test_expected[i], out);\n            else begin\n                $display(\"    %08b, %03b      |  %08b  |  %08b  |   Fail\", in, shift, test_expected[i], out);\n                errors = errors + 1;\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "bitwise_not",
            "Problem": "Write a Verilog module that computes the bitwise NOT of an 8-bit input.",
            "Module header": "module bitwise_not (\n    input [7:0] in,\n    output [7:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule bitwise_not_tb;\n    reg  [7:0] in;         // Input signal to the DUT\n    wire [7:0] out;        // DUT output\n    reg  [7:0] expected;   // Expected output (bitwise NOT of 'in')\n    integer i;             // Loop variable for test vectors\n    integer errors;        // Count of test failures\n\n    // Instantiate the Device Under Test (DUT)\n    bitwise_not uut (\n        .in(in),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        \n        // Display header for the testbench results.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output   | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Loop through a set of test input values (here: 0 to 15)\n        // You can easily extend the loop if desired.\n        for (i = 0; i < 16; i = i + 1) begin\n            in = i;         // Apply test input value\n            #10;            // Wait for the output to settle\n            expected = ~in; // Compute the expected output\n\n            if (out === expected)\n                $display(\"  %08b   | %08b | %08b |   Pass\", in, expected, out);\n            else begin\n                $display(\"  %08b   | %08b | %08b |   Fail\", in, expected, out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "rotate_left",
            "Problem": "Implement a Verilog module that performs a circular rotate left on an 8-bit input by a variable amount.",
            "Module header": "module rotate_left (\n    input [7:0] in,\n    input [2:0] shift,\n    output [7:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule rotate_left_tb;\n    reg  [7:0] in;\n    reg  [2:0] shift;\n    wire [7:0] out;\n    integer errors;\n    \n    // Instantiate the Device Under Test (DUT)\n    rotate_left dut (\n        .in(in),\n        .shift(shift),\n        .out(out)\n    );\n    \n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\"   Test Input (in, shift)  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Test Case 1:\n        // in = 8'hA5 (1010_0101), shift = 0, output should equal in.\n        in = 8'hA5; shift = 0;\n        #10;\n        if (out === 8'hA5)\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Pass\", in, shift, 8'hA5, out);\n        else begin\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Fail\", in, shift, 8'hA5, out);\n            errors = errors + 1;\n        end\n        \n        // Test Case 2:\n        // in = 8'hA5, shift = 1.\n        // Rotate left by 1: 1010_0101 becomes 0100_1011 = 8'h4B.\n        in = 8'hA5; shift = 1;\n        #10;\n        if (out === 8'h4B)\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Pass\", in, shift, 8'h4B, out);\n        else begin\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Fail\", in, shift, 8'h4B, out);\n            errors = errors + 1;\n        end\n        \n        // Test Case 3:\n        // in = 8'hA5, shift = 2.\n        // For 1010_0101, a rotate left by 2 moves the two MSBs to the LSB side.\n        // Expected: {in[5:0], in[7:6]} = {6'b100101, 2'b10} = 8'b10010110 = 8'h96.\n        in = 8'hA5; shift = 2;\n        #10;\n        if (out === 8'h96)\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Pass\", in, shift, 8'h96, out);\n        else begin\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Fail\", in, shift, 8'h96, out);\n            errors = errors + 1;\n        end\n        \n        // Test Case 4:\n        // in = 8'hFF, shift = 3.\n        // For an input of all ones, the rotated result is still all ones.\n        in = 8'hFF; shift = 3;\n        #10;\n        if (out === 8'hFF)\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Pass\", in, shift, 8'hFF, out);\n        else begin\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Fail\", in, shift, 8'hFF, out);\n            errors = errors + 1;\n        end\n        \n        // Test Case 5:\n        // in = 8'h80 (1000_0000), shift = 1.\n        // Expected: rotate left moves the MSB to the LSB \u2192 0000_0001 = 8'h01.\n        in = 8'h80; shift = 1;\n        #10;\n        if (out === 8'h01)\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Pass\", in, shift, 8'h01, out);\n        else begin\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Fail\", in, shift, 8'h01, out);\n            errors = errors + 1;\n        end\n        \n        // Test Case 6:\n        // in = 8'h01 (0000_0001), shift = 7.\n        // Expected: rotate left by 7 will move the LSB to the MSB position \u2192 1000_0000 = 8'h80.\n        in = 8'h01; shift = 7;\n        #10;\n        if (out === 8'h80)\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Pass\", in, shift, 8'h80, out);\n        else begin\n            $display(\"   in = %02h, shift = %0d   |   %02h   | %02h  |   Fail\", in, shift, 8'h80, out);\n            errors = errors + 1;\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule"
        }
    ],
    "Pipelining": [
        {
            "module": "pipelined_adder",
            "Problem": "Implement a pipelined 16-bit adder with a 2-stage pipeline. The first stage should compute the lower 8 bits, and the second stage should compute the upper 8 bits with carry propagation.",
            "Module header": "module pipelined_adder (\n    input clk, rst,\n    input [15:0] a, b,\n    output reg [15:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule pipelined_adder_tb;\n    reg clk, rst;\n    reg [15:0] a, b;\n    wire [15:0] out;\n    reg [15:0] expected;\n    integer errors, i;\n\n    // Instantiate the DUT\n    pipelined_adder dut (\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .out(out)\n    );\n\n    // Clock generation: 10 ns period.\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // Test procedure\n    initial begin\n        errors = 0;\n        rst = 1;\n        a = 16'b0;\n        b = 16'b0;\n        #12;          // Hold reset for a little over one clock cycle\n        rst = 0;\n\n        // Wait two clock cycles to flush the pipeline after reset.\n        @(posedge clk);\n        @(posedge clk);\n\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input         | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Apply a series of test cases.\n        // Note: Because the adder is pipelined, the output corresponds to the inputs\n        // applied two clock cycles earlier.\n        for (i = 0; i < 10; i = i + 1) begin\n            // Generate test vectors.\n            // (You can choose any pattern; here we use a simple sequence for illustration.)\n            a = i * 16'h0011;  // e.g. 0, 0x0011, 0x0022, ...\n            b = i * 16'h0101;  // e.g. 0, 0x0101, 0x0202, ...\n            expected = a + b;  // 16-bit addition (modulo 2^16)\n\n            // Wait two clock cycles for the pipeline to produce the result.\n            @(posedge clk);\n            @(posedge clk);\n\n            if (out === expected)\n                $display(\"   a=%04h, b=%04h  |   %04h   |  %04h  |   Pass\", a, b, expected, out);\n            else begin\n                $display(\"   a=%04h, b=%04h  |   %04h   |  %04h  |   Fail\", a, b, expected, out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\n\nendmodule\n"
        },
        {
            "module": "pipelined_multiplier",
            "Problem": "Design a pipelined 8-bit multiplier with a 3-stage pipeline. The first stage should compute partial products, the second stage should accumulate them, and the third stage should handle the final sum.",
            "Module header": "module pipelined_multiplier (\n    input clk, rst,\n    input [7:0] a, b,\n    output reg [15:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule pipelined_multiplier_tb;\n    reg clk, rst;\n    reg [7:0] a, b;\n    wire [15:0] out;\n    integer errors;\n    reg [15:0] expected;\n\n    // Instantiate the pipelined multiplier.\n    pipelined_multiplier uut (\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .out(out)\n    );\n\n    // Clock generation: 10 ns period.\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // Testbench\n    initial begin\n        errors = 0;\n        \n        // Apply reset for 20 ns (two clock cycles).\n        rst = 1;\n        a = 8'd0; b = 8'd0;\n        #20;\n        rst = 0;\n        \n        // Wait a short time after reset.\n        #10;\n\n        // Display header for the test results.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input        | Expected      | Output        | Pass/Fail \");\n        $display(\"---------------------------------------------------------------\");\n\n        // --- Test Case 1 ---\n        // a = 5, b = 10, expected = 50.\n        @(posedge clk);\n          a = 8'd5; b = 8'd10;\n          expected = 8'd5 * 8'd10;\n        // Wait for 3 clock cycles (pipeline latency).\n        repeat(3) @(posedge clk);\n          if (out === expected)\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Pass\", a, b, expected, out);\n          else begin\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Fail\", a, b, expected, out);\n              errors = errors + 1;\n          end\n\n        // --- Test Case 2 ---\n        // a = 15, b = 3, expected = 45.\n        @(posedge clk);\n          a = 8'd15; b = 8'd3;\n          expected = 8'd15 * 8'd3;\n        repeat(3) @(posedge clk);\n          if (out === expected)\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Pass\", a, b, expected, out);\n          else begin\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Fail\", a, b, expected, out);\n              errors = errors + 1;\n          end\n\n        // --- Test Case 3 ---\n        // a = 20, b = 20, expected = 400.\n        @(posedge clk);\n          a = 8'd20; b = 8'd20;\n          expected = 8'd20 * 8'd20;\n        repeat(3) @(posedge clk);\n          if (out === expected)\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Pass\", a, b, expected, out);\n          else begin\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Fail\", a, b, expected, out);\n              errors = errors + 1;\n          end\n\n        // --- Test Case 4 ---\n        // a = 255, b = 1, expected = 255.\n        @(posedge clk);\n          a = 8'd255; b = 8'd1;\n          expected = 8'd255 * 8'd1;\n        repeat(3) @(posedge clk);\n          if (out === expected)\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Pass\", a, b, expected, out);\n          else begin\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Fail\", a, b, expected, out);\n              errors = errors + 1;\n          end\n\n        // --- Test Case 5 ---\n        // a = 100, b = 2, expected = 200.\n        @(posedge clk);\n          a = 8'd100; b = 8'd2;\n          expected = 8'd100 * 8'd2;\n        repeat(3) @(posedge clk);\n          if (out === expected)\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Pass\", a, b, expected, out);\n          else begin\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Fail\", a, b, expected, out);\n              errors = errors + 1;\n          end\n\n        // --- Test Case 6 ---\n        // a = 7, b = 8, expected = 56.\n        @(posedge clk);\n          a = 8'd7; b = 8'd8;\n          expected = 8'd7 * 8'd8;\n        repeat(3) @(posedge clk);\n          if (out === expected)\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Pass\", a, b, expected, out);\n          else begin\n              $display(\"   a=%3d, b=%3d  | %5d         | %5d         |   Fail\", a, b, expected, out);\n              errors = errors + 1;\n          end\n\n        $display(\"---------------------------------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "pipelined_accumulator",
            "Problem": "Design a pipelined accumulator that sums a stream of 8-bit inputs over 4 clock cycles. Use a 2-stage pipeline to improve throughput.",
            "Module header": "module pipelined_accumulator (\n    input clk, rst,\n    input [7:0] x,\n    output reg [15:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule pipelined_accumulator_tb;\n    reg clk, rst;\n    reg [7:0] x;\n    wire [15:0] out;\n    \n    integer cycle, errors;\n    integer group;  // to index the expected group sum\n    \n    // Instantiate the DUT.\n    pipelined_accumulator dut (\n        .clk(clk),\n        .rst(rst),\n        .x(x),\n        .out(out)\n    );\n    \n    // Clock generation: 10 time-unit period.\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n    \n    // Define an array of test inputs.\n    // We'll supply inputs for 13 clock cycles so that we can check three groups:\n    //   Group 0 (cycles 0-3): 1, 2, 3, 4   -> Expected sum: 10\n    //   Group 1 (cycles 4-7): 10, 20, 30, 40 -> Expected sum: 100\n    //   Group 2 (cycles 8-11): 5, 5, 5, 5    -> Expected sum: 20\n    // Cycle 12 is a dummy input to allow group 2's result to propagate.\n    reg [7:0] test_inputs [0:12];\n    initial begin\n        // Group 0: cycles 0-3\n        test_inputs[0]  = 8'd1;\n        test_inputs[1]  = 8'd2;\n        test_inputs[2]  = 8'd3;\n        test_inputs[3]  = 8'd4;\n        // Group 1: cycles 4-7\n        test_inputs[4]  = 8'd10;\n        test_inputs[5]  = 8'd20;\n        test_inputs[6]  = 8'd30;\n        test_inputs[7]  = 8'd40;\n        // Group 2: cycles 8-11\n        test_inputs[8]  = 8'd5;\n        test_inputs[9]  = 8'd5;\n        test_inputs[10] = 8'd5;\n        test_inputs[11] = 8'd5;\n        // Cycle 12: extra cycle (dummy value) to let group 2's result appear.\n        test_inputs[12] = 8'd0;\n    end\n    \n    // Expected group sums.\n    reg [15:0] expected_sum [0:2];\n    initial begin\n        expected_sum[0] = 16'd10;   // 1+2+3+4 = 10\n        expected_sum[1] = 16'd100;  // 10+20+30+40 = 100\n        expected_sum[2] = 16'd20;   // 5+5+5+5 = 20\n    end\n    \n    // Main test process.\n    initial begin\n        errors = 0;\n        \n        // Apply reset.\n        rst = 1;\n        x = 8'd0;\n        #12;  // wait a bit more than one clock cycle\n        rst = 0;\n        \n        // Display header.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Drive the test inputs over 13 clock cycles.\n        // Note: The design produces a valid group sum one cycle after the group is completed.\n        for (cycle = 0; cycle < 13; cycle = cycle + 1) begin\n            @(posedge clk);\n            x = test_inputs[cycle];\n            \n            // Check the output at cycles when a group's result is expected:\n            // Group 0's sum is available at cycle 4,\n            // Group 1's sum at cycle 8,\n            // Group 2's sum at cycle 12.\n            if (cycle == 4 || cycle == 8 || cycle == 12) begin\n                if (cycle == 4)\n                    group = 0;\n                else if (cycle == 8)\n                    group = 1;\n                else if (cycle == 12)\n                    group = 2;\n                \n                #1;  // allow output to settle\n                if (out === expected_sum[group])\n                    $display(\"   Cycle %0d  |   %05d   |  %05d |   Pass\", cycle, expected_sum[group], out);\n                else begin\n                    $display(\"   Cycle %0d  |   %05d   |  %05d |   Fail\", cycle, expected_sum[group], out);\n                    errors = errors + 1;\n                end\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "pipelined_max_finder",
            "Problem": "Implement a pipelined module to find the maximum value in a stream of 8-bit integers over 4 clock cycles, so it takes four 8-bit inputs. Use a 2-stage pipeline for comparison and selection.", 
            "Module header": "module pipelined_max_finder (\n    input clk, rst,\n    input [7:0] x0,x1,x2,x3,\n    output reg [7:0] max_value\n);", 
            "Testbench": "`timescale 1ns/1ps\nmodule pipelined_max_finder_tb;\n\n    reg clk;\n    reg rst;\n    reg [7:0] x0, x1, x2, x3;\n    wire [7:0] max_value;\n\n    // Instantiate the Unit Under Test (UUT)\n    pipelined_max_finder uut (\n        .clk(clk),\n        .rst(rst),\n        .x0(x0),\n        .x1(x1),\n        .x2(x2),\n        .x3(x3),\n        .max_value(max_value)\n    );\n\n    // Clock generation: period = 10ns\n    initial clk = 0;\n    always #5 clk = ~clk;\n\n    // Test case arrays (4 test cases)\n    reg [7:0] test_x0 [0:3];\n    reg [7:0] test_x1 [0:3];\n    reg [7:0] test_x2 [0:3];\n    reg [7:0] test_x3 [0:3];\n    reg [7:0] expected [0:3];\n\n    integer i;\n    integer errors;\n\n    initial begin\n        errors = 0;\n        // Initialize test vectors.\n        // Test Case 0: {10, 20, 5, 15} -> Expected max = 20\n        test_x0[0] = 8'd10; test_x1[0] = 8'd20; test_x2[0] = 8'd5;  test_x3[0] = 8'd15; expected[0] = 8'd200;\n        // Test Case 1: {100, 50, 200, 150} -> Expected max = 200\n        test_x0[1] = 8'd100; test_x1[1] = 8'd50; test_x2[1] = 8'd200; test_x3[1] = 8'd150; expected[1] = 8'd0;\n        // Test Case 2: {0, 0, 0, 0} -> Expected max = 0\n        test_x0[2] = 8'd0; test_x1[2] = 8'd0; test_x2[2] = 8'd0;  test_x3[2] = 8'd0; expected[2] = 8'd255;\n        // Test Case 3: {255, 100, 200, 250} -> Expected max = 255\n        test_x0[3] = 8'd255; test_x1[3] = 8'd100; test_x2[3] = 8'd200; test_x3[3] = 8'd250; expected[3] = 8'd255;\n\n        // Apply reset.\n        rst = 1;\n        x0 = 8'd0; x1 = 8'd0; x2 = 8'd0; x3 = 8'd0;\n        #12;\n        rst = 0;\n\n        // Apply the test vectors on successive clock cycles.\n        for (i = 0; i < 4; i = i + 1) begin\n            @(negedge clk);\n            x0 <= test_x0[i];\n            x1 <= test_x1[i];\n            x2 <= test_x2[i];\n            x3 <= test_x3[i];\n        end\n\n        // After applying test vectors, drive zeros to flush the pipeline.\n        x0 = 8'd0; x1 = 8'd0; x2 = 8'd0; x3 = 8'd0;\n\n        // Wait for 4 clock cycles to capture the outputs corresponding to the test cases.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        for (i = 0; i < 4; i = i + 1) begin\n            @(negedge clk);\n            if (max_value === expected[i]) begin\n                $display(\" %3d, %3d, %3d, %3d |   %3d    |   %3d  | PASS\", \n                         test_x0[i], test_x1[i], test_x2[i], test_x3[i], expected[i], max_value);\n            end else begin\n                $display(\" %3d, %3d, %3d, %3d |   %3d    |   %3d  | FAIL\", \n                         test_x0[i], test_x1[i], test_x2[i], test_x3[i], expected[i], max_value);\n                errors = errors + 1;\n            end\n        end\n        $display(\"=====================================\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\n\nendmodule"
        },
        {
            "module": "pipelined_fir",
            "Problem": "Implement a 4-tap pipelined FIR filter with 8-bit coefficients and 8-bit input data. Use a 3-stage pipeline to compute the filter output.",
            "Module header": "module pipelined_fir (\n    input clk, rst,\n    input [7:0] x,\n    output reg [15:0] y\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule pipelined_fir_tb;\n    reg clk, rst;\n    reg [7:0] x;\n    wire [15:0] y;\n    \n    integer cycle, errors;\n    integer i;\n    \n    // Instantiate the FIR filter.\n    pipelined_fir dut (\n        .clk(clk),\n        .rst(rst),\n        .x(x),\n        .y(y)\n    );\n    \n    // Clock generation: period = 10 time-units.\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n    \n    // Define a test vector for 16 clock cycles.\n    // (These values will be applied one per clock cycle.)\n    reg [7:0] test_inputs [0:15];\n    initial begin\n        test_inputs[0]  = 8'd1;\n        test_inputs[1]  = 8'd2;\n        test_inputs[2]  = 8'd3;\n        test_inputs[3]  = 8'd4;\n        test_inputs[4]  = 8'd5;\n        test_inputs[5]  = 8'd6;\n        test_inputs[6]  = 8'd7;\n        test_inputs[7]  = 8'd8;\n        test_inputs[8]  = 8'd9;\n        test_inputs[9]  = 8'd10;\n        test_inputs[10] = 8'd11;\n        test_inputs[11] = 8'd12;\n        test_inputs[12] = 8'd13;\n        test_inputs[13] = 8'd14;\n        test_inputs[14] = 8'd15;\n        test_inputs[15] = 8'd16;\n    end\n    \n    // Pre-calculate expected outputs.\n    // Because our pipeline uses shift registers and three pipelined stages,\n    // the total latency is 4 clock cycles.\n    // For cycles 0 to 6, the filter window is not yet full so we expect 0.\n    // For cycle n (n >= 7), the expected output is:\n    //   expected = 1*test_inputs[n-4] + 2*test_inputs[n-5] +\n    //              3*test_inputs[n-6] + 4*test_inputs[n-7]\n    reg [15:0] expected [0:15];\n    initial begin\n        for (i = 0; i < 7; i = i + 1) begin\n            expected[i] = 16'd0;\n        end\n        for (i = 7; i < 16; i = i + 1) begin\n            expected[i] = ( 1 * test_inputs[i-4] ) +\n                          ( 2 * test_inputs[i-5] ) +\n                          ( 3 * test_inputs[i-6] ) +\n                          ( 4 * test_inputs[i-7] );\n        end\n    end\n    \n    // Main test process.\n    initial begin\n        errors = 0;\n        \n        // Apply reset.\n        rst = 1;\n        x = 8'd0;\n        #12;  // Wait a little over one clock cycle.\n        rst = 0;\n        \n        // Display header.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // For each cycle, drive the test input and (after a small delay) check y.\n        for (cycle = 0; cycle < 16; cycle = cycle + 1) begin\n            @(posedge clk);\n            x = test_inputs[cycle];\n            #1;  // Allow y to settle.\n            if (y === expected[cycle])\n                $display(\"   Cycle %0d  |   %05d   |  %05d |   Pass\", cycle, expected[cycle], y);\n            else begin\n                $display(\"   Cycle %0d  |   %05d   |  %05d |   Fail\", cycle, expected[cycle], y);\n                errors = errors + 1;\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        }
    ],
    "Polynomial Evaluation": [
        {
            "module": "polynomial_1",
            "Problem": "Write a Verilog module that computes y = x^2 + 2x + 1, where x is a signed 8-bit integer and y is a signed 16-bit integer.",
            "Module header": "module polynomial_1 (\n    input signed [7:0] in_0,\n    output signed [15:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule polynomial_1_tb;\n    reg  signed [7:0] in_0;\n    wire signed [15:0] out;\n    integer errors;\n    reg signed [15:0] expected;\n    \n    // Instantiate the DUT\n    polynomial_1 dut (\n        .in_0(in_0),\n        .out(out)\n    );\n    \n    initial begin\n        errors = 0;\n        \n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Test case 1: in_0 = -128\n        in_0 = -128;\n        #10; // wait for the output to settle\n        expected = (in_0 + 1) * (in_0 + 1); // (-128 + 1) * (-128 + 1) = (-127)^2 = 16129\n        if (out === expected)\n            $display(\"   %4d      |  %6d  |  %6d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"   %4d      |  %6d  |  %6d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n        \n        // Test case 2: in_0 = -10\n        in_0 = -10;\n        #10;\n        expected = (in_0 + 1) * (in_0 + 1); // (-10 + 1) = -9, (-9)^2 = 81\n        if (out === expected)\n            $display(\"   %4d      |  %6d  |  %6d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"   %4d      |  %6d  |  %6d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n        \n        // Test case 3: in_0 = -1\n        in_0 = -1;\n        #10;\n        expected = (in_0 + 1) * (in_0 + 1); // ( -1 + 1 ) = 0, 0^2 = 0\n        if (out === expected)\n            $display(\"   %4d      |  %6d  |  %6d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"   %4d      |  %6d  |  %6d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n        \n        // Test case 4: in_0 = 0\n        in_0 = 0;\n        #10;\n        expected = (0 + 1) * (0 + 1); // 1*1 = 1\n        if (out === expected)\n            $display(\"   %4d      |  %6d  |  %6d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"   %4d      |  %6d  |  %6d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n        \n        // Test case 5: in_0 = 1\n        in_0 = 1;\n        #10;\n        expected = (1 + 1) * (1 + 1); // 2*2 = 4\n        if (out === expected)\n            $display(\"   %4d      |  %6d  |  %6d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"   %4d      |  %6d  |  %6d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n        \n        // Test case 6: in_0 = 2\n        in_0 = 2;\n        #10;\n        expected = (2 + 1) * (2 + 1); // 3*3 = 9\n        if (out === expected)\n            $display(\"   %4d      |  %6d  |  %6d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"   %4d      |  %6d  |  %6d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n        \n        // Test case 7: in_0 = 10\n        in_0 = 10;\n        #10;\n        expected = (10 + 1) * (10 + 1); // 11*11 = 121\n        if (out === expected)\n            $display(\"   %4d      |  %6d  |  %6d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"   %4d      |  %6d  |  %6d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n        \n        // Test case 8: in_0 = 127\n        in_0 = 127;\n        #10;\n        expected = (127 + 1) * (127 + 1); // 128*128 = 16384\n        if (out === expected)\n            $display(\"   %4d      |  %6d  |  %6d  |   Pass\", in_0, expected, out);\n        else begin\n            $display(\"   %4d      |  %6d  |  %6d  |   Fail\", in_0, expected, out);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "polynomial_2",
            "Problem": "Implement a Verilog module that computes y = x^3 + 3x^2 + 3x + 1, where x is a signed 8-bit integer and y is a signed 24-bit integer.",
            "Module header": "module polynomial_2 (\n    input signed [7:0] in_0,\n    output signed [23:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule polynomial_2_tb;\n    reg  signed [7:0] in_0;\n    wire signed [23:0] out;\n    integer i, errors;\n    reg signed [23:0] expected;\n    \n    // Instantiate the DUT.\n    polynomial_2 uut (\n        .in_0(in_0),\n        .out(out)\n    );\n    \n    // Define a set of test vectors.\n    // (You can add more test cases if desired.)\n    // Here we test a variety of values including negative, zero, and positive.\n    reg signed [7:0] test_vec[0:7];\n    \n    // Function to calculate the expected value: (x + 1)^3.\n    function signed [23:0] calc_expected;\n        input signed [7:0] x;\n        reg signed [23:0] temp;\n        begin\n            temp = (x + 1) * (x + 1) * (x + 1);\n            calc_expected = temp;\n        end\n    endfunction\n\n    initial begin\n        // Initialize test vectors.\n        test_vec[0] = -128;\n        test_vec[1] = -2;\n        test_vec[2] = -1;\n        test_vec[3] = 0;\n        test_vec[4] = 1;\n        test_vec[5] = 2;\n        test_vec[6] = 10;\n        test_vec[7] = 127;\n        \n        errors = 0;\n        \n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Loop through each test vector.\n        for (i = 0; i < 8; i = i + 1) begin\n            in_0 = test_vec[i];\n            #10;  // Wait a short time for the output to settle.\n            \n            expected = calc_expected(test_vec[i]);\n            \n            if (out === expected)\n                $display(\"    %4d    |  %8d | %8d |   Pass\", test_vec[i], expected, out);\n            else begin\n                $display(\"    %4d    |  %8d | %8d |   Fail\", test_vec[i], expected, out);\n                errors = errors + 1;\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "polynomial_3",
            "Problem": "Design a Verilog module that computes y= x^2 - x - 6, where x is a signed 8-bit integer and y is a signed 16-bit integer.",
            "Module header": "module polynomial_3 (\n    input signed [7:0] in_0,\n    output signed [15:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule polynomial_3_tb;\n    reg signed [7:0] in_0;\n    wire signed [15:0] out;\n    integer i, errors;\n    reg signed [7:0] test_val;\n    reg signed [15:0] expected;\n\n    // Instantiate the DUT\n    polynomial_3 dut (\n        .in_0(in_0),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        \n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Apply a set of 12 test cases.\n        // The following test cases are chosen:\n        //   x      : expected y = x^2 - x - 6\n        // -128    :  (-128)^2 - (-128) - 6 = 16384 + 128 - 6 = 16506\n        //  -10    :  100 + 10 - 6 = 104\n        //   -5    :   25 + 5 - 6  = 24\n        //   -2    :    4 + 2 - 6  = 0\n        //   -1    :    1 + 1 - 6  = -4\n        //    0    :    0 - 0 - 6  = -6\n        //    1    :    1 - 1 - 6  = -6\n        //    2    :    4 - 2 - 6  = -4\n        //    3    :    9 - 3 - 6  = 0\n        //    5    :   25 - 5 - 6  = 14\n        //   10    :  100 - 10 - 6  = 84\n        //   127   : 16129 - 127 - 6 = 15996\n        for (i = 0; i < 12; i = i + 1) begin\n            if (i == 0) begin\n                test_val = -128;\n                expected = 16506;\n            end else if (i == 1) begin\n                test_val = -10;\n                expected = 104;\n            end else if (i == 2) begin\n                test_val = -5;\n                expected = 24;\n            end else if (i == 3) begin\n                test_val = -2;\n                expected = 0;\n            end else if (i == 4) begin\n                test_val = -1;\n                expected = -4;\n            end else if (i == 5) begin\n                test_val = 0;\n                expected = -6;\n            end else if (i == 6) begin\n                test_val = 1;\n                expected = -6;\n            end else if (i == 7) begin\n                test_val = 2;\n                expected = -4;\n            end else if (i == 8) begin\n                test_val = 3;\n                expected = 0;\n            end else if (i == 9) begin\n                test_val = 5;\n                expected = 14;\n            end else if (i == 10) begin\n                test_val = 10;\n                expected = 84;\n            end else if (i == 11) begin\n                test_val = 127;\n                expected = 15996;\n            end\n\n            in_0 = test_val;\n            #10;  // Allow time for the combinational logic to compute\n            \n            if (out === expected)\n                $display(\"      %4d   |   %5d  | %5d  |   Pass\", test_val, expected, out);\n            else begin\n                $display(\"      %4d   |   %5d  | %5d  |   Fail\", test_val, expected, out);\n                errors = errors + 1;\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "polynomial_4",
            "Problem": "Design a Verilog module that computes y= (x+2)^2 + (x+2)^2 + (x+2)^2, where x is a signed 8-bit integer and y is a signed 32-bit integer.",
            "Module header": "module polynomial_4 (\n    input signed [7:0] in_0,\n    output signed [31:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule polynomial_4_tb;\n    reg  signed [7:0] in_0;\n    wire signed [31:0] out;\n    integer errors, i;\n    reg  signed [31:0] expected;\n\n    // Instantiate the DUT.\n    polynomial_4 dut (\n        .in_0(in_0),\n        .out(out)\n    );\n\n    // Define a set of test vectors.\n    // (We use 8 test cases including extreme and typical values.)\n    reg signed [7:0] test_vals [0:7];\n    initial begin\n        test_vals[0] = -128;  // extreme negative\n        test_vals[1] = -10;\n        test_vals[2] = -2;\n        test_vals[3] = 0;\n        test_vals[4] = 1;\n        test_vals[5] = 2;\n        test_vals[6] = 10;\n        test_vals[7] = 127;   // extreme positive\n    end\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected |   Output   | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Loop through each test vector.\n        for (i = 0; i < 8; i = i + 1) begin\n            in_0 = test_vals[i];\n            #10;  // Wait for the combinational logic to settle.\n            // Compute expected value: out = 3 * ((in_0+2)^2)\n            expected = 3 * ((in_0 + 2) * (in_0 + 2));\n            if (out === expected)\n                $display(\"   %4d     |   %10d  |   %10d |   Pass\", in_0, expected, out);\n            else begin\n                $display(\"   %4d     |   %10d  |   %10d |   Fail\", in_0, expected, out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "polynomial_5",
            "Problem": "Implement a Verilog module that computes y= (a+b)^2 - (a-b)^2, where a and b are signed 8-bit integers, and y is a signed 16-bit integer.",
            "Module header": "module polynomial_5 (\n    input signed [7:0] in_0,\n    input signed [7:0] in_1,\n    output signed [15:0] out\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule polynomial_5_tb;\n    reg  signed [7:0] in_0;\n    reg  signed [7:0] in_1;\n    wire signed [15:0] out;\n    integer i, errors;\n\n    // Number of test cases.\n    parameter NUM_TESTS = 6;\n\n    // Arrays for test vectors (signed 8-bit) and expected results (signed 16-bit).\n    reg signed [7:0] test_a [0:NUM_TESTS-1];\n    reg signed [7:0] test_b [0:NUM_TESTS-1];\n    reg signed [15:0] expected [0:NUM_TESTS-1];\n\n    // Instantiate the Device Under Test (DUT)\n    polynomial_5 dut (\n        .in_0(in_0),\n        .in_1(in_1),\n        .out(out)\n    );\n\n    // Initialize test vectors.\n    initial begin\n        // Test Case 0: a = 10, b = 5   => Expected: 4 * 10 * 5   = 200\n        test_a[0] = 8'd10;\n        test_b[0] = 8'd5;\n        expected[0] = 16'd200;\n        \n        // Test Case 1: a = -3, b = 7   => Expected: 4 * (-3) * 7 = -84\n        test_a[1] = -8'd3;\n        test_b[1] = 8'd7;\n        expected[1] = -16'd84;\n        \n        // Test Case 2: a = 0, b = 0    => Expected: 0\n        test_a[2] = 8'd0;\n        test_b[2] = 8'd0;\n        expected[2] = 16'd0;\n        \n        // Test Case 3: a = -10, b = -10 => Expected: 4 * (-10) * (-10) = 400\n        test_a[3] = -8'd10;\n        test_b[3] = -8'd10;\n        expected[3] = 16'd400;\n        \n        // Test Case 4: a = 12, b = -3  => Expected: 4 * 12 * (-3) = -144\n        test_a[4] = 8'd12;\n        test_b[4] = -8'd3;\n        expected[4] = -16'd144;\n        \n        // Test Case 5: a = 100, b = 25 => Expected: 4 * 100 * 25 = 10000\n        test_a[5] = 8'd100;\n        test_b[5] = 8'd25;\n        expected[5] = 16'd10000;\n    end\n\n    // Main test process.\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Iterate through all test cases.\n        for (i = 0; i < NUM_TESTS; i = i + 1) begin\n            in_0 = test_a[i];\n            in_1 = test_b[i];\n            #10; // Wait for the combinational logic to settle.\n\n            if (out === expected[i])\n                $display(\"    %3d, %3d  |   %6d | %6d |   Pass\", test_a[i], test_b[i], expected[i], out);\n            else begin\n                $display(\"    %3d, %3d  |   %6d | %6d |   Fail\", test_a[i], test_b[i], expected[i], out);\n                errors = errors + 1;\n            end\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        }
    ],
    "Machine Learning": [
        {
            "module": "matrix_vector_mult",
            "Problem": "Implement a Verilog module to multiply a 4x4 matrix by a 4x1 vector. The output should be a 4x1 vector. The input and output should be flattened.",
            "Module header": "module matrix_vector_mult (input signed [15:0] in_0_0, input signed [15:0] in_0_1, input signed [15:0] in_0_2, input signed [15:0] in_0_3, input signed [15:0] in_0_4, input signed [15:0] in_0_5, input signed [15:0] in_0_6, input signed [15:0] in_0_7, input signed [15:0] in_0_8, input signed [15:0] in_0_9, input signed [15:0] in_0_10, input signed [15:0] in_0_11, input signed [15:0] in_0_12, input signed [15:0] in_0_13, input signed [15:0] in_0_14, input signed [15:0] in_0_15, input signed [15:0] in_1_0, input signed [15:0] in_1_1, input signed [15:0] in_1_2, input signed [15:0] in_1_3, output signed [31:0] out_0, output signed [31:0] out_1, output signed [31:0] out_2, output signed [31:0] out_3);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule matrix_vector_mult_tb;\n    // Matrix inputs (flattened as 16 signed 16-bit numbers)\n    reg signed [15:0] in_0_0, in_0_1, in_0_2, in_0_3;\n    reg signed [15:0] in_0_4, in_0_5, in_0_6, in_0_7;\n    reg signed [15:0] in_0_8, in_0_9, in_0_10, in_0_11;\n    reg signed [15:0] in_0_12, in_0_13, in_0_14, in_0_15;\n    \n    // Vector inputs (flattened as 4 signed 16-bit numbers)\n    reg signed [15:0] in_1_0, in_1_1, in_1_2, in_1_3;\n    \n    // Outputs (flattened 4x1 vector)\n    wire signed [31:0] out_0, out_1, out_2, out_3;\n    \n    integer errors;\n\n    // Instantiate the DUT.\n    matrix_vector_mult dut (\n        .in_0_0(in_0_0),   .in_0_1(in_0_1),   .in_0_2(in_0_2),   .in_0_3(in_0_3),\n        .in_0_4(in_0_4),   .in_0_5(in_0_5),   .in_0_6(in_0_6),   .in_0_7(in_0_7),\n        .in_0_8(in_0_8),   .in_0_9(in_0_9),   .in_0_10(in_0_10), .in_0_11(in_0_11),\n        .in_0_12(in_0_12), .in_0_13(in_0_13), .in_0_14(in_0_14), .in_0_15(in_0_15),\n        .in_1_0(in_1_0),   .in_1_1(in_1_1),   .in_1_2(in_1_2),   .in_1_3(in_1_3),\n        .out_0(out_0),     .out_1(out_1),     .out_2(out_2),     .out_3(out_3)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input       | Expected          | Output            | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // ------------------\n        // Test Case 1: Identity matrix multiplied by a vector.\n        // Matrix (Identity):\n        //   Row0: 1, 0, 0, 0\n        //   Row1: 0, 1, 0, 0\n        //   Row2: 0, 0, 1, 0\n        //   Row3: 0, 0, 0, 1\n        // Vector: {10, 20, 30, 40}\n        // Expected output: {10, 20, 30, 40}\n        in_0_0  = 16'd1;  in_0_1  = 16'd0;  in_0_2  = 16'd0;  in_0_3  = 16'd0;\n        in_0_4  = 16'd0;  in_0_5  = 16'd1;  in_0_6  = 16'd0;  in_0_7  = 16'd0;\n        in_0_8  = 16'd0;  in_0_9  = 16'd0;  in_0_10 = 16'd1;  in_0_11 = 16'd0;\n        in_0_12 = 16'd0;  in_0_13 = 16'd0;  in_0_14 = 16'd0;  in_0_15 = 16'd1;\n        in_1_0  = 16'd10; in_1_1  = 16'd20; in_1_2  = 16'd30; in_1_3  = 16'd40;\n        #10;\n        if (out_0 === 32'd10 && out_1 === 32'd20 && out_2 === 32'd30 && out_3 === 32'd40)\n            $display(\"   TC1: Identity  | [10,20,30,40]     | [%0d,%0d,%0d,%0d] |   Pass\", out_0, out_1, out_2, out_3);\n        else begin\n            $display(\"   TC1: Identity  | [10,20,30,40]     | [%0d,%0d,%0d,%0d] |   Fail\", out_0, out_1, out_2, out_3);\n            errors = errors + 1;\n        end\n\n        // ------------------\n        // Test Case 2: Arbitrary matrix and vector.\n        // Matrix:\n        //   Row0: 2, 3, 4, 5\n        //   Row1: 1, -1, 2, 0\n        //   Row2: 0, 10, 0, -2\n        //   Row3: 3, 3, 3, 3\n        // Vector: {1, 2, 3, 4}\n        // Expected output:\n        //   out_0 = 2*1 + 3*2 + 4*3 + 5*4 = 2 + 6 + 12 + 20 = 40\n        //   out_1 = 1*1 + (-1)*2 + 2*3 + 0*4 = 1 - 2 + 6 + 0 = 5\n        //   out_2 = 0*1 + 10*2 + 0*3 + (-2)*4 = 0 + 20 + 0 - 8 = 12\n        //   out_3 = 3*1 + 3*2 + 3*3 + 3*4 = 3 + 6 + 9 + 12 = 30\n        in_0_0  = 16'd2;   in_0_1  = 16'd3;   in_0_2  = 16'd4;   in_0_3  = 16'd5;\n        in_0_4  = 16'd1;   in_0_5  = -16'd1;  in_0_6  = 16'd2;   in_0_7  = 16'd0;\n        in_0_8  = 16'd0;   in_0_9  = 16'd10;  in_0_10 = 16'd0;   in_0_11 = -16'd2;\n        in_0_12 = 16'd3;   in_0_13 = 16'd3;   in_0_14 = 16'd3;   in_0_15 = 16'd3;\n        in_1_0  = 16'd1;   in_1_1  = 16'd2;   in_1_2  = 16'd3;   in_1_3  = 16'd4;\n        #10;\n        if (out_0 === 32'd40 && out_1 === 32'd5 && out_2 === 32'd12 && out_3 === 32'd30)\n            $display(\"   TC2: Arbitrary | [40,5,12,30]      | [%0d,%0d,%0d,%0d] |   Pass\", out_0, out_1, out_2, out_3);\n        else begin\n            $display(\"   TC2: Arbitrary | [40,5,12,30]      | [%0d,%0d,%0d,%0d] |   Fail\", out_0, out_1, out_2, out_3);\n            errors = errors + 1;\n        end\n\n        // ------------------\n        // Test Case 3: Mixed/negative values.\n        // Matrix:\n        //   Row0: -1, -2, -3, -4\n        //   Row1: -1, -1, -1, -1\n        //   Row2: 5, 0, -5, 0\n        //   Row3: 10, 20, 30, 40\n        // Vector: {1, 1, 1, 1}\n        // Expected output:\n        //   out_0 = -1 -2 -3 -4 = -10\n        //   out_1 = -1 -1 -1 -1 = -4\n        //   out_2 = 5 + 0 -5 + 0 = 0\n        //   out_3 = 10 + 20 + 30 + 40 = 100\n        in_0_0  = -16'd1;  in_0_1  = -16'd2;  in_0_2  = -16'd3;  in_0_3  = -16'd4;\n        in_0_4  = -16'd1;  in_0_5  = -16'd1;  in_0_6  = -16'd1;  in_0_7  = -16'd1;\n        in_0_8  = 16'd5;   in_0_9  = 16'd0;   in_0_10 = -16'd5;  in_0_11 = 16'd0;\n        in_0_12 = 16'd10;  in_0_13 = 16'd20;  in_0_14 = 16'd30;  in_0_15 = 16'd40;\n        in_1_0  = 16'd1;   in_1_1  = 16'd1;   in_1_2  = 16'd1;   in_1_3  = 16'd1;\n        #10;\n        if (out_0 === -32'd10 && out_1 === -32'd4 && out_2 === 32'd0 && out_3 === 32'd100)\n            $display(\"   TC3: Mixed     | [-10,-4,0,100]    | [%0d,%0d,%0d,%0d] |   Pass\", out_0, out_1, out_2, out_3);\n        else begin\n            $display(\"   TC3: Mixed     | [-10,-4,0,100]    | [%0d,%0d,%0d,%0d] |   Fail\", out_0, out_1, out_2, out_3);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "relu",
            "Problem": "Implement a Verilog module to compute the ReLU activation function.",
            "Module header": "module relu (\n    input signed [15:0] in_0,\n    output signed [15:0] out);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule relu_tb;\n    reg  signed [15:0] in_0;\n    wire signed [15:0] out;\n    integer i;\n    integer errors;\n    \n    // Instantiate the DUT.\n    relu dut (\n        .in_0(in_0),\n        .out(out)\n    );\n    \n    // Define test vectors.\n    // Using arrays (supported in Verilog-2001) for a fixed set of test cases.\n    reg signed [15:0] test_inputs [0:4];\n    reg signed [15:0] expected_outputs [0:4];\n    \n    initial begin\n        // Test case 0: Negative value should yield 0.\n        test_inputs[0]     = -16'sd100;\n        expected_outputs[0]=  16'sd0;\n        \n        // Test case 1: Zero should yield 0.\n        test_inputs[1]     = 16'sd0;\n        expected_outputs[1]= 16'sd0;\n        \n        // Test case 2: Positive value should pass through.\n        test_inputs[2]     = 16'sd50;\n        expected_outputs[2]= 16'sd50;\n        \n        // Test case 3: Small negative value.\n        test_inputs[3]     = -16'sd1;\n        expected_outputs[3]= 16'sd0;\n        \n        // Test case 4: Larger positive value.\n        test_inputs[4]     = 16'sd12345;\n        expected_outputs[4]= 16'sd12345;\n    end\n    \n    // Main test process.\n    initial begin\n        errors = 0;\n        // Display header.\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Loop through each test vector.\n        for (i = 0; i < 5; i = i + 1) begin\n            in_0 = test_inputs[i];\n            #10;  // Wait for the output to settle.\n            if (out === expected_outputs[i])\n                $display(\"   %6d   |   %6d |  %6d |   Pass\", test_inputs[i], expected_outputs[i], out);\n            else begin\n                $display(\"   %6d   |   %6d |  %6d |   Fail\", test_inputs[i], expected_outputs[i], out);\n                errors = errors + 1;\n            end\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "gradient_descent",
            "Problem": "Implement a Verilog module to perform a single step of gradient descent for the weight update. The inputs are the gradient, learning rate, and current weight. The output should be the updated weight.",
            "Module header": "module gradient_descent (\n    input signed [31:0] in_0,\n    input signed [31:0] in_1,\n    input signed [31:0] in_2,\n    output signed [31:0] out);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule gradient_descent_tb;\n    reg  signed [31:0] in_0, in_1, in_2;\n    wire signed [31:0] out;\n    \n    integer i, errors;\n    \n    // Declare arrays to hold test vectors and expected outputs.\n    // (Verilog\u20112001 supports one\u2010dimensional arrays for simulation purposes.)\n    reg signed [31:0] test_grad   [0:3];\n    reg signed [31:0] test_lr     [0:3];\n    reg signed [31:0] test_weight [0:3];\n    reg signed [31:0] expected_out[0:3];\n    \n    // Instantiate the DUT.\n    gradient_descent dut (\n        .in_0(in_0),\n        .in_1(in_1),\n        .in_2(in_2),\n        .out(out)\n    );\n    \n    initial begin\n        errors = 0;\n        // Test Case 0:\n        // gradient = 2, learning_rate = 3, current_weight = 10\n        // updated_weight = 10 - (2 * 3) = 10 - 6 = 4\n        test_grad[0]   = 32'sd2;\n        test_lr[0]     = 32'sd3;\n        test_weight[0] = 32'sd10;\n        expected_out[0]= 32'sd4;\n        \n        // Test Case 1:\n        // gradient = -2, learning_rate = 3, current_weight = 10\n        // updated_weight = 10 - (-2 * 3) = 10 - (-6) = 16\n        test_grad[1]   = -32'sd2;\n        test_lr[1]     = 32'sd3;\n        test_weight[1] = 32'sd10;\n        expected_out[1]= 32'sd16;\n        \n        // Test Case 2:\n        // gradient = 2, learning_rate = -3, current_weight = 10\n        // updated_weight = 10 - (2 * -3) = 10 - (-6) = 16\n        test_grad[2]   = 32'sd2;\n        test_lr[2]     = -32'sd3;\n        test_weight[2] = 32'sd10;\n        expected_out[2]= 32'sd16;\n        \n        // Test Case 3:\n        // gradient = 4, learning_rate = 5, current_weight = 100\n        // updated_weight = 100 - (4 * 5) = 100 - 20 = 80\n        test_grad[3]   = 32'sd4;\n        test_lr[3]     = 32'sd5;\n        test_weight[3] = 32'sd100;\n        expected_out[3]= 32'sd80;\n        \n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input                        | Expected   | Output     | Pass/Fail \");\n        $display(\"--------------------------------------------------------------------------\");\n        \n        for (i = 0; i < 4; i = i + 1) begin\n            in_0 = test_grad[i];\n            in_1 = test_lr[i];\n            in_2 = test_weight[i];\n            #10; // Wait for combinational logic to settle.\n            if (out === expected_out[i])\n                $display(\" Case %0d: grad=%0d, lr=%0d, weight=%0d | %0d       | %0d       |   Pass\", \n                         i, in_0, in_1, in_2, expected_out[i], out);\n            else begin\n                $display(\" Case %0d: grad=%0d, lr=%0d, weight=%0d | %0d       | %0d       |   Fail\", \n                         i, in_0, in_1, in_2, expected_out[i], out);\n                errors = errors + 1;\n            end\n        end\n        \n        $display(\"--------------------------------------------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "mse_loss",
            "Problem": "Implement a Verilog module to compute the mean squared error (MSE) between two 4-element vectors.",
            "Module header": "module mse_loss (\n    input signed [15:0] in_0_0, input signed [15:0] in_0_1, input signed [15:0] in_0_2, input signed [15:0] in_0_3, // Ground truth vector\n    input signed [15:0] in_1_0, input signed [15:0] in_1_1, input signed [15:0] in_1_2, input signed [15:0] in_1_3, // Predicted vector\n    output signed [31:0] out);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule mse_loss_tb;\n    // Declare inputs as registers and the output as a wire.\n    reg  signed [15:0] in_0_0, in_0_1, in_0_2, in_0_3;\n    reg  signed [15:0] in_1_0, in_1_1, in_1_2, in_1_3;\n    wire signed [31:0] out;\n    integer errors;\n\n    // Instantiate the DUT.\n    mse_loss dut (\n        .in_0_0(in_0_0), .in_0_1(in_0_1), .in_0_2(in_0_2), .in_0_3(in_0_3),\n        .in_1_0(in_1_0), .in_1_1(in_1_1), .in_1_2(in_1_2), .in_1_3(in_1_3),\n        .out(out)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input             | Expected | Output   | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test Case 1:\n        // Ground truth: {1, 2, 3, 4}\n        // Predicted:    {1, 2, 3, 4}  -> differences all 0, MSE = 0.\n        in_0_0 = 16'd1;  in_0_1 = 16'd2;  in_0_2 = 16'd3;  in_0_3 = 16'd4;\n        in_1_0 = 16'd1;  in_1_1 = 16'd2;  in_1_2 = 16'd3;  in_1_3 = 16'd4;\n        #10; // Allow time for combinational logic to settle.\n        if (out === 32'd0)\n            $display(\" {1,2,3,4} / {1,2,3,4}   |    0     | %08d |   Pass\", out);\n        else begin\n            $display(\" {1,2,3,4} / {1,2,3,4}   |    0     | %08d |   Fail\", out);\n            errors = errors + 1;\n        end\n\n        // Test Case 2:\n        // Ground truth: {10, 20, 30, 40}\n        // Predicted:    {8, 18, 33, 41}\n        // Differences:  2, 2, -3, -1; Squares: 4, 4, 9, 1; Sum = 18; MSE = 18/4 = 4 (integer division).\n        in_0_0 = 16'd10;  in_0_1 = 16'd20;  in_0_2 = 16'd30;  in_0_3 = 16'd40;\n        in_1_0 = 16'd8;   in_1_1 = 16'd18;  in_1_2 = 16'd33;  in_1_3 = 16'd41;\n        #10;\n        if (out === 32'd4)\n            $display(\" {10,20,30,40} / {8,18,33,41} |    4     | %08d |   Pass\", out);\n        else begin\n            $display(\" {10,20,30,40} / {8,18,33,41} |    4     | %08d |   Fail\", out);\n            errors = errors + 1;\n        end\n\n        // Test Case 3:\n        // Ground truth: {100, -50, 25, -10}\n        // Predicted:    {90, -45, 20, -12}\n        // Differences:  10, -5, 5, 2; Squares: 100, 25, 25, 4; Sum = 154; MSE = 154/4 = 38 (truncated).\n        in_0_0 = 16'd100;  in_0_1 = -16'd50;  in_0_2 = 16'd25;   in_0_3 = -16'd10;\n        in_1_0 = 16'd90;   in_1_1 = -16'd45;  in_1_2 = 16'd20;   in_1_3 = -16'd12;\n        #10;\n        if (out === 32'd38)\n            $display(\" {100,-50,25,-10} / {90,-45,20,-12} |   38     | %08d |   Pass\", out);\n        else begin\n            $display(\" {100,-50,25,-10} / {90,-45,20,-12} |   38     | %08d |   Fail\", out);\n            errors = errors + 1;\n        end\n\n        // Test Case 4:\n        // Ground truth: {-10, -20, -30, -40}\n        // Predicted:    {-10, -20, -30, -40} -> differences all 0, MSE = 0.\n        in_0_0 = -16'd10;  in_0_1 = -16'd20;  in_0_2 = -16'd30;  in_0_3 = -16'd40;\n        in_1_0 = -16'd10;  in_1_1 = -16'd20;  in_1_2 = -16'd30;  in_1_3 = -16'd40;\n        #10;\n        if (out === 32'd0)\n            $display(\" {-10,-20,-30,-40} / {-10,-20,-30,-40} |    0     | %08d |   Pass\", out);\n        else begin\n            $display(\" {-10,-20,-30,-40} / {-10,-20,-30,-40} |    0     | %08d |   Fail\", out);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "conv2d",
            "Problem": "Implement a Verilog module to perform 2D convolution on a 3x3 matrix with a 2x2 kernel, so no padding is needed here. The output should be a 2x2 matrix. The input image, kernel and output should be flattened.",
            "Module header": "module conv2d (\n    input signed [15:0] in_0_0, input signed [15:0] in_0_1, input signed [15:0] in_0_2, input signed [15:0] in_0_3, input signed [15:0] in_0_4, input signed [15:0] in_0_5, input signed [15:0] in_0_6, input signed [15:0] in_0_7, input signed [15:0] in_0_8,\n    input signed [15:0] in_1_0, input signed [15:0] in_1_1, input signed [15:0] in_1_2, input signed [15:0] in_1_3,\n    output signed [31:0] out_0, output signed [31:0] out_1, output signed [31:0] out_2, output signed [31:0] out_3);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule conv2d_tb;\n    // Declare image inputs (3x3) and kernel inputs (2x2)\n    reg signed [15:0] in_0_0, in_0_1, in_0_2, in_0_3, in_0_4, in_0_5, in_0_6, in_0_7, in_0_8;\n    reg signed [15:0] in_1_0, in_1_1, in_1_2, in_1_3;\n    // Declare outputs (2x2)\n    wire signed [31:0] out_0, out_1, out_2, out_3;\n    \n    integer errors;\n    \n    // Expected outputs (temporary registers)\n    reg signed [31:0] exp0, exp1, exp2, exp3;\n    \n    // Instantiate the DUT.\n    conv2d uut (\n        .in_0_0(in_0_0), .in_0_1(in_0_1), .in_0_2(in_0_2),\n        .in_0_3(in_0_3), .in_0_4(in_0_4), .in_0_5(in_0_5),\n        .in_0_6(in_0_6), .in_0_7(in_0_7), .in_0_8(in_0_8),\n        .in_1_0(in_1_0), .in_1_1(in_1_1), .in_1_2(in_1_2), .in_1_3(in_1_3),\n        .out_0(out_0), .out_1(out_1), .out_2(out_2), .out_3(out_3)\n    );\n    \n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input   | Expected                 | Output                   | Pass/Fail \");\n        $display(\"-----------------------------------------------------------------------\");\n        \n        // ----------------------------\n        // Test Case 1:\n        // Image:  1  2  3\n        //         4  5  6\n        //         7  8  9\n        // Kernel: 1  0\n        //         0  1\n        // Expected:\n        // out_0 = 1*1 + 2*0 + 4*0 + 5*1 = 1 + 5 = 6\n        // out_1 = 2*1 + 3*0 + 5*0 + 6*1 = 2 + 6 = 8\n        // out_2 = 4*1 + 5*0 + 7*0 + 8*1 = 4 + 8 = 12\n        // out_3 = 5*1 + 6*0 + 8*0 + 9*1 = 5 + 9 = 14\n        in_0_0 = 16'd1;  in_0_1 = 16'd2;  in_0_2 = 16'd3;\n        in_0_3 = 16'd4;  in_0_4 = 16'd5;  in_0_5 = 16'd6;\n        in_0_6 = 16'd7;  in_0_7 = 16'd8;  in_0_8 = 16'd9;\n        in_1_0 = 16'd1;  in_1_1 = 16'd0;  in_1_2 = 16'd0;  in_1_3 = 16'd1;\n        #10; // Allow combinational logic to settle.\n        exp0 = 32'd6; exp1 = 32'd8; exp2 = 32'd12; exp3 = 32'd14;\n        if ((out_0 === exp0) && (out_1 === exp1) && (out_2 === exp2) && (out_3 === exp3))\n            $display(\"   Case 1     | [6, 8, 12, 14]           | [%0d, %0d, %0d, %0d]       |   Pass\", out_0, out_1, out_2, out_3);\n        else begin\n            $display(\"   Case 1     | [6, 8, 12, 14]           | [%0d, %0d, %0d, %0d]       |   Fail\", out_0, out_1, out_2, out_3);\n            errors = errors + 1;\n        end\n        \n        // ----------------------------\n        // Test Case 2:\n        // Image:  -1,  0,  1\n        //         2, -2,  3\n        //         4,  5, -6\n        // Kernel: 0,  1\n        //        -1,  2\n        // Expected:\n        // out_0 = (-1*0) + (0*1) + (2*(-1)) + (-2*2) = 0 + 0 -2 -4 = -6\n        // out_1 = (0*0) + (1*1) + (-2*(-1)) + (3*2) = 0 + 1 +2 +6 = 9\n        // out_2 = (2*0) + (-2*1) + (4*(-1)) + (5*2) = 0 -2 -4 +10 = 4\n        // out_3 = (-2*0) + (3*1) + (5*(-1)) + (-6*2) = 0 +3 -5 -12 = -14\n        in_0_0 = -16'd1; in_0_1 = 16'd0;  in_0_2 = 16'd1;\n        in_0_3 = 16'd2;  in_0_4 = -16'd2; in_0_5 = 16'd3;\n        in_0_6 = 16'd4;  in_0_7 = 16'd5;  in_0_8 = -16'd6;\n        in_1_0 = 16'd0;  in_1_1 = 16'd1;  in_1_2 = -16'd1; in_1_3 = 16'd2;\n        #10;\n        exp0 = -32'd6; exp1 = 32'd9; exp2 = 32'd4; exp3 = -32'd14;\n        if ((out_0 === exp0) && (out_1 === exp1) && (out_2 === exp2) && (out_3 === exp3))\n            $display(\"   Case 2     | [-6, 9, 4, -14]          | [%0d, %0d, %0d, %0d]       |   Pass\", out_0, out_1, out_2, out_3);\n        else begin\n            $display(\"   Case 2     | [-6, 9, 4, -14]          | [%0d, %0d, %0d, %0d]       |   Fail\", out_0, out_1, out_2, out_3);\n            errors = errors + 1;\n        end\n        \n        // ----------------------------\n        // Test Case 3:\n        // Image:  10, 20, 30\n        //         40, 50, 60\n        //         70, 80, 90\n        // Kernel: 1, 1\n        //         1, 1\n        // Expected:\n        // out_0 = 10+20+40+50 = 120\n        // out_1 = 20+30+50+60 = 160\n        // out_2 = 40+50+70+80 = 240\n        // out_3 = 50+60+80+90 = 280\n        in_0_0 = 16'd10; in_0_1 = 16'd20; in_0_2 = 16'd30;\n        in_0_3 = 16'd40; in_0_4 = 16'd50; in_0_5 = 16'd60;\n        in_0_6 = 16'd70; in_0_7 = 16'd80; in_0_8 = 16'd90;\n        in_1_0 = 16'd1;  in_1_1 = 16'd1;  in_1_2 = 16'd1;  in_1_3 = 16'd1;\n        #10;\n        exp0 = 32'd120; exp1 = 32'd160; exp2 = 32'd240; exp3 = 32'd280;\n        if ((out_0 === exp0) && (out_1 === exp1) && (out_2 === exp2) && (out_3 === exp3))\n            $display(\"   Case 3     | [120, 160, 240, 280]      | [%0d, %0d, %0d, %0d]       |   Pass\", out_0, out_1, out_2, out_3);\n        else begin\n            $display(\"   Case 3     | [120, 160, 240, 280]      | [%0d, %0d, %0d, %0d]       |   Fail\", out_0, out_1, out_2, out_3);\n            errors = errors + 1;\n        end\n        \n        $display(\"-----------------------------------------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        }
    ],
    "Financial Computing": [
        {
            "module": "compound_interest",
            "Problem": "Design a Verilog module that computes the compound interest A = P \u8133 ( 1 + r )^n,  where P is the principal amount (16-bit unsigned integer),  r is the interest rate (8-bit fixed-point representation), and  n is the number of compounding periods (8-bit unsigned integer). The output  A should be a 32-bit unsigned integer.",
            "Module header": "module compound_interest (\n    input [15:0] P,\n    input [7:0] r,\n    input [7:0] n,\n    output [31:0] A\n);",
            "Testbench": "`timescale 1ns/1ps\n\nmodule compound_interest_tb;\n    reg  [15:0] P;\n    reg  [7:0]  r;\n    reg  [7:0]  n;\n    wire [31:0] A;\n    integer errors;\n    reg [31:0] expected;\n\n    // Instantiate the DUT.\n    compound_interest dut (\n        .P(P),\n        .r(r),\n        .n(n),\n        .A(A)\n    );\n\n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input           | Expected  | Output    | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test Case 1:\n        // n = 0 should yield A = P.\n        // Example: P = 1000, r = 50 (any value), n = 0 -> A = 1000.\n        P = 16'd1000; r = 8'd50; n = 8'd0;\n        #10;  // Allow combinational logic to settle.\n        expected = 1000;\n        if (A === expected)\n            $display(\" P=%d, r=%d, n=%d   | %08d | %08d |   Pass\", P, r, n, expected, A);\n        else begin\n            $display(\" P=%d, r=%d, n=%d   | %08d | %08d |   Fail\", P, r, n, expected, A);\n            errors = errors + 1;\n        end\n\n        // Test Case 2:\n        // Zero interest: r = 0. Then A = P regardless of n.\n        // Example: P = 1000, r = 0, n = 5 -> A = 1000.\n        P = 16'd1000; r = 8'd0; n = 8'd5;\n        #10;\n        expected = 1000;\n        if (A === expected)\n            $display(\" P=%d, r=%d, n=%d   | %08d | %08d |   Pass\", P, r, n, expected, A);\n        else begin\n            $display(\" P=%d, r=%d, n=%d   | %08d | %08d |   Fail\", P, r, n, expected, A);\n            errors = errors + 1;\n        end\n\n\n        // Test Case 4:\n        // Example: P = 2000, r = 64 (25% interest), n = 3.\n        // Calculation: (1+64/256) = 1.25; 1.25^3 = 1.953125; 2000*1.953125 = 3906.25 \u2192 expected = 3906.\n        P = 16'd2000; r = 8'd64; n = 8'd3;\n        #10;\n        expected = 3906;\n        if (A === expected)\n            $display(\" P=%d, r=%d, n=%d   | %08d | %08d |   Pass\", P, r, n, expected, A);\n        else begin\n            $display(\" P=%d, r=%d, n=%d   | %08d | %08d |   Fail\", P, r, n, expected, A);\n            errors = errors + 1;\n        end\n\n        // Test Case 5:\n        // Example: P = 500, r = 50 (~19.53%), n = 1.\n        // Calculation: (1+50/256) \u2248 1.1953; 500*1.1953 \u2248 597.65 \u2192 expected = 597.\n        P = 16'd500; r = 8'd50; n = 8'd1;\n        #10;\n        expected = 597;\n        if (A === expected)\n            $display(\" P=%d, r=%d, n=%d   | %08d | %08d |   Pass\", P, r, n, expected, A);\n        else begin\n            $display(\" P=%d, r=%d, n=%d   | %08d | %08d |   Fail\", P, r, n, expected, A);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        $display(\"=====================================\");\n        $finish;\n    end\nendmodule\n"
        },
        {
            "module": "ddm",
            "Problem": "Implement a Verilog module that calculates the Dividend Discount Model (ddm) value of a stock. The inputs are the expected dividend (16-bit unsigned integer), required rate of return (8-bit fixed-point representation), and growth rate (8-bit fixed-point representation). The ddm formula is given as: ddm Value = Expected Dividend / (Required Rate of Return - Growth Rate), where the required rate of return and growth rate are expressed as fractions (e.g., an 8-bit fixed-point value of 128 corresponds to 0.5). Ensure the module handles cases where the required rate of return is equal to or less than the growth rate to avoid division by zero or negative results. The output ddm value should be a 32-bit unsigned integer.",
            "Module Header": "module ddm (\n    input [15:0] expected_dividend,\n    input [7:0] required_rate_of_return,\n    input [7:0] growth_rate,\n    output reg [31:0] ddm_value\n);",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_ddm;\n\n  // Testbench signals\n  reg  [15:0] expected_dividend;\n  reg  [7:0]  required_rate_of_return;\n  reg  [7:0]  growth_rate;\n  wire [31:0] ddm_value;\n  \n  // Instantiate the ddm calculation module.\n  ddm uut (\n    .expected_dividend(expected_dividend),\n    .required_rate_of_return(required_rate_of_return),\n    .growth_rate(growth_rate),\n    .ddm_value(ddm_value)\n  );\n  \n  integer errors;\n  reg [31:0] expected;\n\n  initial begin\n    errors = 0;\n    \n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input                          | Expected | Output  | Pass/Fail \");\n    $display(\"---------------------------------------------------------------------\");\n    \n    // Test 1:\n    // expected_dividend = 100, required_rate_of_return = 200, growth_rate = 100.\n    // Denom = 200 - 100 = 100, so ddm = (100 * 256)/100 = 256.\n    expected_dividend    = 16'd100;\n    required_rate_of_return = 8'd200;\n    growth_rate          = 8'd100;\n    #10;\n    expected = 32'd256;\n    if (ddm_value == expected)\n      $display(\"   1: ED=%d, ROR=%d, GR=%d |   %d   |   %d   | PASS\", \n                expected_dividend, required_rate_of_return, growth_rate, expected, ddm_value);\n    else begin\n      $display(\"   1: ED=%d, ROR=%d, GR=%d |   %d   |   %d   | FAIL\", \n                expected_dividend, required_rate_of_return, growth_rate, expected, ddm_value);\n      errors = errors + 1;\n    end\n\n    // Test 2:\n    // expected_dividend = 50, required_rate_of_return = 150, growth_rate = 50.\n    // Denom = 150 - 50 = 100, so ddm = (50 * 256)/100 = 128.\n    expected_dividend    = 16'd50;\n    required_rate_of_return = 8'd150;\n    growth_rate          = 8'd50;\n    #10;\n    expected = 32'd128;\n    if (ddm_value == expected)\n      $display(\"   2: ED=%d, ROR=%d, GR=%d |   %d   |   %d   | PASS\", \n                expected_dividend, required_rate_of_return, growth_rate, expected, ddm_value);\n    else begin\n      $display(\"   2: ED=%d, ROR=%d, GR=%d |   %d   |   %d   | FAIL\", \n                expected_dividend, required_rate_of_return, growth_rate, expected, ddm_value);\n      errors = errors + 1;\n    end\n\n\n    // Test 5:\n    // expected_dividend = 300, required_rate_of_return = 180, growth_rate = 80.\n    // Denom = 180 - 80 = 100, so ddm = (300 * 256)/100 = 768.\n    expected_dividend    = 16'd300;\n    required_rate_of_return = 8'd180;\n    growth_rate          = 8'd80;\n    #10;\n    expected = 32'd768;\n    if (ddm_value == expected)\n      $display(\"   5: ED=%d, ROR=%d, GR=%d |   %d   |   %d   | PASS\", \n                expected_dividend, required_rate_of_return, growth_rate, expected, ddm_value);\n    else begin\n      $display(\"   5: ED=%d, ROR=%d, GR=%d |   %d   |   %d   | FAIL\", \n                expected_dividend, required_rate_of_return, growth_rate, expected, ddm_value);\n      errors = errors + 1;\n    end\n\n    // Test 6:\n    // Edge case with large dividend.\n    // expected_dividend = 65535, required_rate_of_return = 250, growth_rate = 200.\n    // Denom = 250 - 200 = 50, so ddm = (65535 * 256)/50.\n    // Calculation: (65535*256)=16776960, divided by 50 gives 335539 (integer division).\n    expected_dividend    = 16'd65535;\n    required_rate_of_return = 8'd250;\n    growth_rate          = 8'd200;\n    #10;\n    expected = 32'd335539;\n    if (ddm_value == expected)\n      $display(\"   6: ED=%d, ROR=%d, GR=%d |   %d   |   %d   | PASS\", \n                expected_dividend, required_rate_of_return, growth_rate, expected, ddm_value);\n    else begin\n      $display(\"   6: ED=%d, ROR=%d, GR=%d |   %d   |   %d   | FAIL\", \n                expected_dividend, required_rate_of_return, growth_rate, expected, ddm_value);\n      errors = errors + 1;\n    end\n\n    $display(\"---------------------------------------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed: %d error(s)\", errors);\n\n    $finish;\n  end\n\nendmodule\n"
        },
        {
            "module": "present_value",
            "Problem": "Write a Verilog module to compute the present value of a future amount. The module takes a 16-bit future amount, an 8-bit annual interest rate (in percent), and an 8-bit number of periods, and outputs a 16-bit present value computed as future_amount / (1 + rate/100)^n using fixed-point arithmetic.",
            "Module header": "module present_value (\n    input [15:0] future_amount,\n    input [7:0] rate,\n    input [7:0] n,\n    output reg [15:0] present_value\n);\n    integer i;\n    reg [31:0] factor;\n    always @(*) begin\n        factor = 32'd100; // Represent 1.00 as 100 in fixed-point arithmetic\n        for (i = 0; i < n; i = i + 1) begin\n            factor = (factor * (100 + rate)) / 100;\n        end\n        present_value = (future_amount * 100) / factor;\n    end\nendmodule",
            "Testbench": "// tb_present_value.v\n`timescale 1ns/1ps\nmodule tb_present_value;\n\n    // Testbench signals\n    reg  [15:0] future_amount;\n    reg  [7:0]  rate;\n    reg  [7:0]  n;\n    wire [15:0] present_value;\n    \n    integer errors;\n    \n    // Instantiate the Unit Under Test (UUT)\n    present_value uut (\n        .future_amount(future_amount),\n        .rate(rate),\n        .n(n),\n        .present_value(present_value)\n    );\n    \n    initial begin\n        errors = 0;\n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input             | Expected | Output | Pass/Fail \");\n        $display(\"---------------------------------------------------------\");\n        \n        // Test 1:\n        // future_amount = 1000, rate = 10, n = 1.\n        // factor = 100 * (110)/100 = 110;\n        // present_value = (1000 * 100) / 110 = 909 (truncated)\n        future_amount = 16'd1000;\n        rate         = 8'd10;\n        n            = 8'd1;\n        #10;\n        if (present_value == 16'd909)\n            $display(\"   1: FA=%d, Rate=%d, n=%d  |   %d   |  %d   | PASS\", \n                     future_amount, rate, n, 16'd909, present_value);\n        else begin\n            $display(\"   1: FA=%d, Rate=%d, n=%d  |   %d   |  %d   | FAIL\", \n                     future_amount, rate, n, 16'd909, present_value);\n            errors = errors + 1;\n        end\n        \n        // Test 2:\n        // future_amount = 2000, rate = 5, n = 2.\n        // Iteration 1: factor = 100 * (105)/100 = 105;\n        // Iteration 2: factor = 105 * (105)/100 = 11025/100 = 110 (truncated);\n        // present_value = (2000 * 100)/110 = 1818 (truncated)\n        future_amount = 16'd2000;\n        rate         = 8'd5;\n        n            = 8'd2;\n        #10;\n        if (present_value == 16'd1818)\n            $display(\"   2: FA=%d, Rate=%d, n=%d  |  1818  |  %d   | PASS\", \n                     future_amount, rate, n, present_value);\n        else begin\n            $display(\"   2: FA=%d, Rate=%d, n=%d  |  1818  |  %d   | FAIL\", \n                     future_amount, rate, n, present_value);\n            errors = errors + 1;\n        end\n        \n        // Test 3:\n        // future_amount = 5000, rate = 0, n = 5.\n        // With zero rate, factor remains 100; thus, present_value = (5000*100)/100 = 5000.\n        future_amount = 16'd5000;\n        rate         = 8'd0;\n        n            = 8'd5;\n        #10;\n        if (present_value == 16'd5000)\n            $display(\"   3: FA=%d, Rate=%d, n=%d  |  5000  |  %d   | PASS\", \n                     future_amount, rate, n, present_value);\n        else begin\n            $display(\"   3: FA=%d, Rate=%d, n=%d  |  5000  |  %d   | FAIL\", \n                     future_amount, rate, n, present_value);\n            errors = errors + 1;\n        end\n        \n        // Test 4:\n        // future_amount = 1000, rate = 20, n = 3.\n        // Iteration 1: factor = 100 * (120)/100 = 120;\n        // Iteration 2: factor = 120 * (120)/100 = 14400/100 = 144;\n        // Iteration 3: factor = 144 * (120)/100 = 17280/100 = 172 (truncated);\n        // present_value = (1000*100)/172 = 581 (truncated)\n        future_amount = 16'd1000;\n        rate         = 8'd20;\n        n            = 8'd3;\n        #10;\n        if (present_value == 16'd581)\n            $display(\"   4: FA=%d, Rate=%d, n=%d  |   581  |  %d   | PASS\", \n                     future_amount, rate, n, present_value);\n        else begin\n            $display(\"   4: FA=%d, Rate=%d, n=%d  |   581  |  %d   | FAIL\", \n                     future_amount, rate, n, present_value);\n            errors = errors + 1;\n        end\n        \n        // Test 5:\n        // future_amount = 3000, rate = 15, n = 4.\n        // Iteration 1: factor = 100 * (115)/100 = 115;\n        // Iteration 2: factor = 115 * (115)/100 = 13225/100 = 132 (truncated);\n        // Iteration 3: factor = 132 * (115)/100 = 15180/100 = 151 (truncated);\n        // Iteration 4: factor = 151 * (115)/100 = 17365/100 = 173 (truncated);\n        // present_value = (3000*100)/173 = 1734 (truncated)\n        future_amount = 16'd3000;\n        rate         = 8'd15;\n        n            = 8'd4;\n        #10;\n        if (present_value == 16'd1734)\n            $display(\"   5: FA=%d, Rate=%d, n=%d  |  1734  |  %d   | PASS\", \n                     future_amount, rate, n, present_value);\n        else begin\n            $display(\"   5: FA=%d, Rate=%d, n=%d  |  1734  |  %d   | FAIL\", \n                     future_amount, rate, n, present_value);\n            errors = errors + 1;\n        end\n        \n        $display(\"---------------------------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        \n        $finish;\n    end\n\nendmodule\n"
        },
        {
            "module": "currency_converter",
            "Problem": "Create a Verilog module that converts an amount from one currency to another using a fixed exchange rate. Inputs include the original currency amount (32-bit unsigned integer) and the exchange rate (16-bit fixed-point). Output the converted amount as a 32-bit unsigned integer.",
            "Module header": "module currency_converter (\n    input [31:0] amount,\n    input [15:0] conversion_rate,\n    output [32:0] converted_amount);",
            "Testbench": "module tb_currency_converter;\n\n    reg [31:0] amount;\n    reg [15:0] conversion_rate;\n    wire [31:0] converted_amount;\n\n    currency_converter dut (\n        .amount(amount),\n        .conversion_rate(conversion_rate),\n        .converted_amount(converted_amount)\n    );\n\n    reg [31:0] expected_value;\n    integer pass_count = 0, fail_count = 0;\n\n    initial begin\n        $display(\"==========Testbench Results==========\");\n        $display(\"=====================================\");\n        $display(\" Amount     | Rate     | Expected   | Output     | Pass/Fail \");\n        $display(\"-------------------------------------------------------------\");\n\n        // Test Case 1: Convert 1000 with exchange rate of 1.5 (fixed-point: 384)\n        amount = 32'd1000;  \n        conversion_rate = 16'd384; // 1.5 in fixed-point (384 / 256)\n        expected_value = (amount * conversion_rate) >> 8;\n        #10;\n        if (converted_amount === expected_value) begin\n            pass_count = pass_count + 1;\n            $display(\" %d     | %d     | %d         | %d         | Pass\", \n                     amount, conversion_rate, expected_value, converted_amount);\n        end else begin\n            fail_count = fail_count + 1;\n            $display(\" %d     | %d     | %d         | %d         | Fail\", \n                     amount, conversion_rate, expected_value, converted_amount);\n        end\n\n        // Test Case 2: Convert 2000 with exchange rate of 0.75 (fixed-point: 192)\n        amount = 32'd2000;\n        conversion_rate = 16'd192; // 0.75 in fixed-point\n        expected_value = (amount * conversion_rate) >> 8;\n        #10;\n        if (converted_amount === expected_value) begin\n            pass_count = pass_count + 1;\n            $display(\" %d     | %d     | %d         | %d         | Pass\", \n                     amount, conversion_rate, expected_value, converted_amount);\n        end else begin\n            fail_count = fail_count + 1;\n            $display(\" %d     | %d     | %d         | %d         | Fail\", \n                     amount, conversion_rate, expected_value, converted_amount);\n        end\n\n        // Test Case 3: Convert 5000 with exchange rate of 2.0 (fixed-point: 512)\n        amount = 32'd5000;\n        conversion_rate = 16'd512; // 2.0 in fixed-point\n        expected_value = (amount * conversion_rate) >> 8;\n        #10;\n        if (converted_amount === expected_value) begin\n            pass_count = pass_count + 1;\n            $display(\" %d     | %d     | %d         | %d         | Pass\", \n                     amount, conversion_rate, expected_value, converted_amount);\n        end else begin\n            fail_count = fail_count + 1;\n            $display(\" %d     | %d     | %d         | %d         | Fail\", \n                     amount, conversion_rate, expected_value, converted_amount);\n        end\n\n        // Final test result summary\n        $display(\"=====================================\");\n        if (fail_count == 0) begin\n            $display(\"All tests passed\");\n        end else begin\n            $display(\"Some tests failed (%d failed, %d passed)\", fail_count, pass_count);\n        end\n    end\nendmodule\n"
        }
    ],
    "Encryption": [
        {
            "module": "caesar_cipher",
            "Problem": "Implement a simple Caesar cipher module that shifts an 8-bit input by a constant value (e.g., 3) modulo 256.",
            "Module header": "module caesar_cipher (\n    input [7:0] data_in,\n    output [7:0] data_out\n);\n    parameter SHIFT = 8'd3;\n    // The addition automatically wraps around in Verilog for fixed-width vectors\n    assign data_out = data_in + SHIFT;\nendmodule",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_caesar_cipher;\n\n  // Testbench signals\n  reg [7:0] data_in;\n  wire [7:0] data_out;\n  integer errors;\n\n  // Instantiate the Unit Under Test (UUT)\n  caesar_cipher uut (\n    .data_in(data_in),\n    .data_out(data_out)\n  );\n  \n  initial begin\n    errors = 0;\n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input  | Expected | Output | Pass/Fail \");\n    $display(\"-------------------------------------\");\n    \n    // Test Case 1:\n    // data_in = 0, expected data_out = 0 + 3 = 3.\n    data_in = 8'd0;\n    #10; // wait for the combinational logic to settle\n    if (data_out == 8'd3)\n      $display(\"    0       |    3     |   %3d  | PASS\", data_out);\n    else begin\n      $display(\"    0       |    3     |   %3d  | FAIL\", data_out);\n      errors = errors + 1;\n    end\n\n    // Test Case 2:\n    // data_in = 1, expected data_out = 1 + 3 = 4.\n    data_in = 8'd1;\n    #10;\n    if (data_out == 8'd4)\n      $display(\"    1       |    4     |   %3d  | PASS\", data_out);\n    else begin\n      $display(\"    1       |    4     |   %3d  | FAIL\", data_out);\n      errors = errors + 1;\n    end\n\n    // Test Case 3:\n    // data_in = 252, expected data_out = 252 + 3 = 255.\n    data_in = 8'd252;\n    #10;\n    if (data_out == 8'd255)\n      $display(\"   252      |   255    |   %3d  | PASS\", data_out);\n    else begin\n      $display(\"   252      |   255    |   %3d  | FAIL\", data_out);\n      errors = errors + 1;\n    end\n\n    // Test Case 4:\n    // data_in = 253, expected data_out = (253 + 3) mod 256 = 0.\n    data_in = 8'd253;\n    #10;\n    if (data_out == 8'd0)\n      $display(\"   253      |    0     |   %3d  | PASS\", data_out);\n    else begin\n      $display(\"   253      |    0     |   %3d  | FAIL\", data_out);\n      errors = errors + 1;\n    end\n\n    // Test Case 5:\n    // data_in = 254, expected data_out = (254 + 3) mod 256 = 1.\n    data_in = 8'd254;\n    #10;\n    if (data_out == 8'd1)\n      $display(\"   254      |    1     |   %3d  | PASS\", data_out);\n    else begin\n      $display(\"   254      |    1     |   %3d  | FAIL\", data_out);\n      errors = errors + 1;\n    end\n\n    // Test Case 6:\n    // data_in = 255, expected data_out = (255 + 3) mod 256 = 2.\n    data_in = 8'd255;\n    #10;\n    if (data_out == 8'd2)\n      $display(\"   255      |    2     |   %3d  | PASS\", data_out);\n    else begin\n      $display(\"   255      |    2     |   %3d  | FAIL\", data_out);\n      errors = errors + 1;\n    end\n\n    $display(\"-------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed\");\n      \n    $finish;\n  end\n\nendmodule\n"
        },
        {
            "module": "modular_add_cipher",
            "Problem": "Implement a modular addition cipher module that adds a fixed key (e.g., 5) to an 8-bit input modulo 256.",
            "Module header": "module modular_add_cipher (\n    input [7:0] data_in,\n    output [7:0] data_out\n);\n    parameter KEY = 8'd5;\n    assign data_out = data_in + KEY;\nendmodule",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_modular_add_cipher;\n\n    // Testbench signals.\n    reg [7:0] data_in;\n    wire [7:0] data_out;\n    \n    // Instantiate the Unit Under Test (UUT)\n    modular_add_cipher uut (\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n    \n    integer errors;\n    \n    initial begin\n        errors = 0;\n        \n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n        \n        // Test case 1: data_in = 0  -> expected output = 0 + 5 = 5.\n        data_in = 8'd0;   #10;\n        if (data_out == 8'd5)\n            $display(\"    %3d      |   %3d   |   %3d  |   PASS\", data_in, 8'd5, data_out);\n        else begin\n            $display(\"    %3d      |   %3d   |   %3d  |   FAIL\", data_in, 8'd5, data_out);\n            errors = errors + 1;\n        end\n        \n        // Test case 2: data_in = 10 -> expected output = 10 + 5 = 15.\n        data_in = 8'd10;  #10;\n        if (data_out == 8'd15)\n            $display(\"    %3d      |   %3d   |   %3d  |   PASS\", data_in, 8'd15, data_out);\n        else begin\n            $display(\"    %3d      |   %3d   |   %3d  |   FAIL\", data_in, 8'd15, data_out);\n            errors = errors + 1;\n        end\n        \n        // Test case 3: data_in = 250 -> expected output = 250 + 5 = 255.\n        data_in = 8'd250; #10;\n        if (data_out == 8'd255)\n            $display(\"    %3d      |   %3d   |   %3d  |   PASS\", data_in, 8'd255, data_out);\n        else begin\n            $display(\"    %3d      |   %3d   |   %3d  |   FAIL\", data_in, 8'd255, data_out);\n            errors = errors + 1;\n        end\n        \n        // Test case 4: data_in = 251 -> expected output = (251 + 5) mod 256 = 0.\n        data_in = 8'd251; #10;\n        if (data_out == 8'd0)\n            $display(\"    %3d      |   %3d   |   %3d  |   PASS\", data_in, 8'd0, data_out);\n        else begin\n            $display(\"    %3d      |   %3d   |   %3d  |   FAIL\", data_in, 8'd0, data_out);\n            errors = errors + 1;\n        end\n        \n        // Test case 5: data_in = 254 -> expected output = (254 + 5) mod 256 = 3.\n        data_in = 8'd254; #10;\n        if (data_out == 8'd3)\n            $display(\"    %3d      |   %3d   |   %3d  |   PASS\", data_in, 8'd3, data_out);\n        else begin\n            $display(\"    %3d      |   %3d   |   %3d  |   FAIL\", data_in, 8'd3, data_out);\n            errors = errors + 1;\n        end\n        \n        // Test case 6: data_in = 255 -> expected output = (255 + 5) mod 256 = 4.\n        data_in = 8'd255; #10;\n        if (data_out == 8'd4)\n            $display(\"    %3d      |   %3d   |   %3d  |   PASS\", data_in, 8'd4, data_out);\n        else begin\n            $display(\"    %3d      |   %3d   |   %3d  |   FAIL\", data_in, 8'd4, data_out);\n            errors = errors + 1;\n        end\n        \n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed: %d error(s)\", errors);\n            \n        $finish;\n    end\n\nendmodule\n"
        },
        {
            "module": "feistel_cipher",
            "Problem": "Implement a Verilog module for a basic block cipher using a Feistel network. The module should take an 8-bit input, split it into two 4-bit halves, and apply a single round of Feistel encryption using a simple round function (e.g., XOR with a fixed key). The workflow involves: 1. Splits an 8-bit input into two 4-bit halves. 2. Applies a round function. 3. Swap the left and right halves after encryption.",
            "Module Header": "module feistel_cipher (\n    input [7:0] data_in,\n    output [7:0] data_out\n);\n    parameter KEY = 4'b1010; // Example key",
            "Testbench": "// tb_feistel_cipher.v\n// Testbench for the feistel_cipher module.\n// It applies several test vectors and displays a table showing the test input,\n// expected output, actual output, and whether the test passed or failed.\n\n`timescale 1ns/1ps\n\nmodule tb_feistel_cipher;\n\n  // Testbench signals\n  reg  [7:0] data_in;\n  wire [7:0] data_out;\n  \n  // Instantiate the Feistel cipher (UUT)\n  feistel_cipher uut (\n      .data_in(data_in),\n      .data_out(data_out)\n  );\n  \n  integer errors;\n  \n  initial begin\n    errors = 0;\n    \n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input  | Expected | Output | Pass/Fail \");\n    $display(\"-------------------------------------\");\n    \n    // Test 1:\n    // data_in = 8'h00\n    // L0 = 4'h0, R0 = 4'h0.\n    // f_out = 0 XOR 1010 = 1010.\n    // R1 = L0 XOR f_out = 0 XOR 1010 = 1010.\n    // L1 = R0 = 0.\n    // After swap, data_out = {R1, L1} = {1010, 0000} = 8'hA0.\n    data_in = 8'h00;\n    #10;\n    if (data_out == 8'hA0)\n      $display(\"    1: %h       |   A0    |  %h   | PASS\", data_in, data_out);\n    else begin\n      $display(\"    1: %h       |   A0    |  %h   | FAIL\", data_in, data_out);\n      errors = errors + 1;\n    end\n\n    // Test 2:\n    // data_in = 8'hFF\n    // L0 = 4'hF, R0 = 4'hF.\n    // f_out = 4'hF XOR 1010 = 4'h5 (since 1111 XOR 1010 = 0101).\n    // R1 = 4'hF XOR 4'h5 = 4'hA (1111 XOR 0101 = 1010).\n    // L1 = R0 = 4'hF.\n    // data_out = {R1, L1} = {1010, 1111} = 8'hAF.\n    data_in = 8'hFF;\n    #10;\n    if (data_out == 8'hAF)\n      $display(\"    2: %h       |   AF    |  %h   | PASS\", data_in, data_out);\n    else begin\n      $display(\"    2: %h       |   AF    |  %h   | FAIL\", data_in, data_out);\n      errors = errors + 1;\n    end\n\n    // Test 3:\n    // data_in = 8'hAB  (A = 1010, B = 1011)\n    // L0 = 1010, R0 = 1011.\n    // f_out = 1011 XOR 1010 = 0001.\n    // R1 = 1010 XOR 0001 = 1011.\n    // L1 = 1011.\n    // data_out = {1011, 1011} = 8'hBB.\n    data_in = 8'hAB;\n    #10;\n    if (data_out == 8'hBB)\n      $display(\"    3: %h       |   BB    |  %h   | PASS\", data_in, data_out);\n    else begin\n      $display(\"    3: %h       |   BB    |  %h   | FAIL\", data_in, data_out);\n      errors = errors + 1;\n    end\n\n    // Test 4:\n    // data_in = 8'h12  (1 = 0001, 2 = 0010)\n    // L0 = 0001, R0 = 0010.\n    // f_out = 0010 XOR 1010 = 1000.\n    // R1 = 0001 XOR 1000 = 1001.\n    // L1 = 0010.\n    // data_out = {1001, 0010} = 8'h92.\n    data_in = 8'h12;\n    #10;\n    if (data_out == 8'h92)\n      $display(\"    4: %h       |   92    |  %h   | PASS\", data_in, data_out);\n    else begin\n      $display(\"    4: %h       |   92    |  %h   | FAIL\", data_in, data_out);\n      errors = errors + 1;\n    end\n\n    // Test 5:\n    // data_in = 8'h3C  (3 = 0011, C = 1100)\n    // L0 = 0011, R0 = 1100.\n    // f_out = 1100 XOR 1010 = 0110.\n    // R1 = 0011 XOR 0110 = 0101.\n    // L1 = 1100.\n    // data_out = {0101, 1100} = 8'h5C.\n    data_in = 8'h3C;\n    #10;\n    if (data_out == 8'h5C)\n      $display(\"    5: %h       |   5C    |  %h   | PASS\", data_in, data_out);\n    else begin\n      $display(\"    5: %h       |   5C    |  %h   | FAIL\", data_in, data_out);\n      errors = errors + 1;\n    end\n    \n    $display(\"-------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed\");\n    \n    $finish;\n  end\n\nendmodule\n"
        }
    ],
    "Physics": [
        {
            "module": "free_fall_distance",
            "Problem": "Implement a Verilog module that calculates the displacement of an object in free-fall using the formula d = (g * t^2) / 2. Assume g is approximated as 10 m/s and the time (t) is provided as an 8-bit unsigned integer (in seconds). The output is a 16-bit unsigned displacement value (in meters).",
            "Module header": "module free_fall_distance (\n    input [7:0] t_in,       // time in seconds\n    output [15:0] distance  // displacement in meters\n);",
            "Testbench": "// tb_free_fall_distance.v\n`timescale 1ns/1ps\nmodule tb_free_fall_distance;\n\n    // Testbench signals\n    reg [7:0] tb_time;       // renamed testbench signal to avoid conflict with Verilog keyword 'time'\n    wire [15:0] distance;    // output from the module\n\n    // Instantiate the Unit Under Test (UUT)\n    free_fall_distance uut (\n        .t_in(tb_time),    // connect tb_time to the module's 't_in' port\n        .distance(distance)\n    );\n\n    integer errors;  // error counter\n\n    initial begin\n        errors = 0;\n        \n        $display(\"==========Testbench results==========\");\n        $display(\"=====================================\");\n        $display(\" Test Input  | Expected | Output | Pass/Fail \");\n        $display(\"-------------------------------------\");\n\n        // Test 1: tb_time = 0 sec, Expected d = (10 * 0^2)/2 = 0\n        tb_time = 8'd0;\n        #10; // wait for propagation\n        if (distance == 16'd0)\n            $display(\"    0 sec   |    0     |  %d    | PASS\", distance);\n        else begin\n            $display(\"    0 sec   |    0     |  %d    | FAIL\", distance);\n            errors = errors + 1;\n        end\n\n        // Test 2: tb_time = 1 sec, Expected d = (10 * 1^2)/2 = 5\n        tb_time = 8'd1;\n        #10;\n        if (distance == 16'd5)\n            $display(\"    1 sec   |    5     |  %d    | PASS\", distance);\n        else begin\n            $display(\"    1 sec   |    5     |  %d    | FAIL\", distance);\n            errors = errors + 1;\n        end\n\n        // Test 3: tb_time = 2 sec, Expected d = (10 * 2^2)/2 = (10 * 4)/2 = 20\n        tb_time = 8'd2;\n        #10;\n        if (distance == 16'd20)\n            $display(\"    2 sec   |   20     |  %d    | PASS\", distance);\n        else begin\n            $display(\"    2 sec   |   20     |  %d    | FAIL\", distance);\n            errors = errors + 1;\n        end\n\n        // Test 4: tb_time = 3 sec, Expected d = (10 * 3^2)/2 = (10 * 9)/2 = 45\n        tb_time = 8'd3;\n        #10;\n        if (distance == 16'd45)\n            $display(\"    3 sec   |   45     |  %d    | PASS\", distance);\n        else begin\n            $display(\"    3 sec   |   45     |  %d    | FAIL\", distance);\n            errors = errors + 1;\n        end\n\n        // Test 5: tb_time = 10 sec, Expected d = (10 * 10^2)/2 = (10 * 100)/2 = 500\n        tb_time = 8'd10;\n        #10;\n        if (distance == 16'd500)\n            $display(\"   10 sec   |   500    |  %d    | PASS\", distance);\n        else begin\n            $display(\"   10 sec   |   500    |  %d    | FAIL\", distance);\n            errors = errors + 1;\n        end\n\n        $display(\"-------------------------------------\");\n        if (errors == 0)\n            $display(\"All tests passed\");\n        else\n            $display(\"Some tests failed\");\n        \n        $finish;\n    end\n\nendmodule\n"
        },
        {
            "module": "kinetic_energy",
            "Problem": "Implement a Verilog module to calculate the kinetic energy of an object using the formula KE = (1/2) * m * v^2. The module takes an 8-bit mass (in kilograms) and an 8-bit velocity (in m/s) as inputs, and outputs a 16-bit kinetic energy value.",
            "Module header": "module kinetic_energy (\n    input [7:0] mass,      // mass in kilograms\n    input [7:0] velocity,  // velocity in m/s\n    output [15:0] energy",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_kinetic_energy;\n\n  // Inputs to the UUT.\n  reg [7:0] mass;\n  reg [7:0] velocity;\n  \n  // Output from the UUT.\n  wire [15:0] energy;\n  \n  // Error counter.\n  integer errors;\n  \n  // Instantiate the Unit Under Test (UUT).\n  kinetic_energy uut (\n    .mass(mass),\n    .velocity(velocity),\n    .energy(energy)\n  );\n  \n  initial begin\n    errors = 0;\n    \n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input             | Expected | Output | Pass/Fail \");\n    $display(\"-------------------------------------\");\n    \n    // Test 1:\n    // mass = 10, velocity = 5.\n    // KE = (1/2) * 10 * (5^2) = (1/2) * 10 * 25 = 125.\n    mass = 8'd10;\n    velocity = 8'd5;\n    #10;\n    if (energy == 16'd125)\n      $display(\" 1: mass=%3d, velocity=%3d |   125   |  %d   | PASS\", mass, velocity, energy);\n    else begin\n      $display(\" 1: mass=%3d, velocity=%3d |   125   |  %d   | FAIL\", mass, velocity, energy);\n      errors = errors + 1;\n    end\n    \n    // Test 2:\n    // mass = 0, velocity = 100.\n    // KE = (1/2) * 0 * (100^2) = 0.\n    mass = 8'd0;\n    velocity = 8'd100;\n    #10;\n    if (energy == 16'd0)\n      $display(\" 2: mass=%3d, velocity=%3d |     0   |  %d   | PASS\", mass, velocity, energy);\n    else begin\n      $display(\" 2: mass=%3d, velocity=%3d |     0   |  %d   | FAIL\", mass, velocity, energy);\n      errors = errors + 1;\n    end\n    \n    // Test 3:\n    // mass = 8, velocity = 8.\n    // KE = (1/2) * 8 * (8^2) = 4 * 64 = 256.\n    mass = 8'd8;\n    velocity = 8'd8;\n    #10;\n    if (energy == 16'd256)\n      $display(\" 3: mass=%3d, velocity=%3d |   256   |  %d   | PASS\", mass, velocity, energy);\n    else begin\n      $display(\" 3: mass=%3d, velocity=%3d |   256   |  %d   | FAIL\", mass, velocity, energy);\n      errors = errors + 1;\n    end\n    \n    // Test 4:\n    // mass = 20, velocity = 15.\n    // KE = (1/2) * 20 * (15^2) = 10 * 225 = 2250.\n    mass = 8'd20;\n    velocity = 8'd15;\n    #10;\n    if (energy == 16'd2250)\n      $display(\" 4: mass=%3d, velocity=%3d |  2250   |  %d   | PASS\", mass, velocity, energy);\n    else begin\n      $display(\" 4: mass=%3d, velocity=%3d |  2250   |  %d   | FAIL\", mass, velocity, energy);\n      errors = errors + 1;\n    end\n    \n    // Test 5:\n    // mass = 30, velocity = 20.\n    // KE = (1/2) * 30 * (20^2) = 15 * 400 = 6000.\n    mass = 8'd30;\n    velocity = 8'd20;\n    #10;\n    if (energy == 16'd6000)\n      $display(\" 5: mass=%3d, velocity=%3d |  6000   |  %d   | PASS\", mass, velocity, energy);\n    else begin\n      $display(\" 5: mass=%3d, velocity=%3d |  6000   |  %d   | FAIL\", mass, velocity, energy);\n      errors = errors + 1;\n    end\n\n    $display(\"-------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed: %d error(s)\", errors);\n    \n    $finish;\n  end\n\nendmodule\n"
        },
        {
            "module": "potential_energy",
            "Problem": "Implement a Verilog module that computes the gravitational potential energy of an object using the formula PE = m * g * h. Assume g is approximated as 10 m/s. The module takes an 8-bit mass (in kilograms) and an 8-bit height (in meters) as inputs, and outputs a 16-bit potential energy value.",
            "Module header": "module potential_energy (\n    input [7:0] mass,      // mass in kilograms\n    input [7:0] height,    // height in meters\n    output [15:0] energy  // potential energy in joules (approx.)\n);",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_potential_energy;\n\n  // Inputs to the Unit Under Test (UUT)\n  reg [7:0] mass;\n  reg [7:0] height;\n  \n  // Output from the UUT\n  wire [15:0] energy;\n  \n  // Error counter\n  integer errors;\n  \n  // Instantiate the potential_energy module\n  potential_energy uut (\n    .mass(mass),\n    .height(height),\n    .energy(energy)\n  );\n  \n  initial begin\n    errors = 0;\n    \n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input             | Expected | Output | Pass/Fail \");\n    $display(\"-------------------------------------\");\n    \n    // Test 1:\n    // mass = 10, height = 5 -> energy = 10 * 5 * 10 = 500.\n    mass = 8'd10;\n    height = 8'd5;\n    #10;\n    if (energy == 16'd500)\n      $display(\" 1: mass=%3d, height=%3d |   500   |  %d   | PASS\", mass, height, energy);\n    else begin\n      $display(\" 1: mass=%3d, height=%3d |   500   |  %d   | FAIL\", mass, height, energy);\n      errors = errors + 1;\n    end\n\n    // Test 2:\n    // mass = 0, height = 100 -> energy = 0 * 100 * 10 = 0.\n    mass = 8'd0;\n    height = 8'd100;\n    #10;\n    if (energy == 16'd0)\n      $display(\" 2: mass=%3d, height=%3d |    0    |  %d   | PASS\", mass, height, energy);\n    else begin\n      $display(\" 2: mass=%3d, height=%3d |    0    |  %d   | FAIL\", mass, height, energy);\n      errors = errors + 1;\n    end\n\n    // Test 3:\n    // mass = 5, height = 20 -> energy = 5 * 20 * 10 = 1000.\n    mass = 8'd5;\n    height = 8'd20;\n    #10;\n    if (energy == 16'd1000)\n      $display(\" 3: mass=%3d, height=%3d |  1000   |  %d   | PASS\", mass, height, energy);\n    else begin\n      $display(\" 3: mass=%3d, height=%3d |  1000   |  %d   | FAIL\", mass, height, energy);\n      errors = errors + 1;\n    end\n\n    // Test 4:\n    // mass = 8, height = 15 -> energy = 8 * 15 * 10 = 1200.\n    mass = 8'd8;\n    height = 8'd15;\n    #10;\n    if (energy == 16'd1200)\n      $display(\" 4: mass=%3d, height=%3d |  1200   |  %d   | PASS\", mass, height, energy);\n    else begin\n      $display(\" 4: mass=%3d, height=%3d |  1200   |  %d   | FAIL\", mass, height, energy);\n      errors = errors + 1;\n    end\n\n    // Test 5:\n    // mass = 25, height = 4 -> energy = 25 * 4 * 10 = 1000.\n    mass = 8'd25;\n    height = 8'd4;\n    #10;\n    if (energy == 16'd1000)\n      $display(\" 5: mass=%3d, height=%3d |  1000   |  %d   | PASS\", mass, height, energy);\n    else begin\n      $display(\" 5: mass=%3d, height=%3d |  1000   |  %d   | FAIL\", mass, height, energy);\n      errors = errors + 1;\n    end\n\n    $display(\"-------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed: %d error(s)\", errors);\n\n    $finish;\n  end\n\nendmodule\n"
        },
        {
            "module": "wavelength",
            "Problem": "Implement a Verilog module that calculates the wavelength of electromagnetic radiation using the formula  = c / f, where c is the speed of light approximated as 300 m/MHz. The module takes an 8-bit frequency input (in MHz) and outputs an 8-bit wavelength value (in meters). For frequency equal to 0, the output should be 0.",
            "Module header": "module wavelength (\n    input [7:0] frequency,   // frequency in MHz\n    output [7:0] wavelength  // wavelength in meters\n);",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_wavelength;\n\n  // Declare testbench signals.\n  reg  [7:0] frequency;\n  wire [7:0] wavelength;\n  integer errors;\n\n  // Instantiate the Unit Under Test (UUT).\n  wavelength uut (\n    .frequency(frequency),\n    .wavelength(wavelength)\n  );\n\n  initial begin\n    errors = 0;\n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input  | Expected | Output | Pass/Fail \");\n    $display(\"-------------------------------------\");\n    \n    // Test 1: frequency = 0 MHz, expected wavelength = 0.\n    frequency = 8'd0;\n    #10;\n    if (wavelength == 8'd0)\n      $display(\"   0 MHz   |    0    |   %3d   | PASS\", wavelength);\n    else begin\n      $display(\"   0 MHz   |    0    |   %3d   | FAIL\", wavelength);\n      errors = errors + 1;\n    end\n\n    // Test 2: frequency = 2 MHz, expected wavelength = 300/2 = 150.\n    frequency = 8'd2;\n    #10;\n    if (wavelength == 8'd150)\n      $display(\"   2 MHz   |   150   |   %3d   | PASS\", wavelength);\n    else begin\n      $display(\"   2 MHz   |   150   |   %3d   | FAIL\", wavelength);\n      errors = errors + 1;\n    end\n\n    // Test 3: frequency = 3 MHz, expected wavelength = 300/3 = 100.\n    frequency = 8'd3;\n    #10;\n    if (wavelength == 8'd100)\n      $display(\"   3 MHz   |   100   |   %3d   | PASS\", wavelength);\n    else begin\n      $display(\"   3 MHz   |   100   |   %3d   | FAIL\", wavelength);\n      errors = errors + 1;\n    end\n\n    // Test 4: frequency = 4 MHz, expected wavelength = 300/4 = 75.\n    frequency = 8'd4;\n    #10;\n    if (wavelength == 8'd75)\n      $display(\"   4 MHz   |    75   |   %3d   | PASS\", wavelength);\n    else begin\n      $display(\"   4 MHz   |    75   |   %3d   | FAIL\", wavelength);\n      errors = errors + 1;\n    end\n\n    // Test 5: frequency = 10 MHz, expected wavelength = 300/10 = 30.\n    frequency = 8'd10;\n    #10;\n    if (wavelength == 8'd30)\n      $display(\"  10 MHz   |    30   |   %3d   | PASS\", wavelength);\n    else begin\n      $display(\"  10 MHz   |    30   |   %3d   | FAIL\", wavelength);\n      errors = errors + 1;\n    end\n\n    // Test 6: frequency = 15 MHz, expected wavelength = 300/15 = 20.\n    frequency = 8'd15;\n    #10;\n    if (wavelength == 8'd20)\n      $display(\"  15 MHz   |    20   |   %3d   | PASS\", wavelength);\n    else begin\n      $display(\"  15 MHz   |    20   |   %3d   | FAIL\", wavelength);\n      errors = errors + 1;\n    end\n\n    // Test 7: frequency = 30 MHz, expected wavelength = 300/30 = 10.\n    frequency = 8'd30;\n    #10;\n    if (wavelength == 8'd10)\n      $display(\"  30 MHz   |    10   |   %3d   | PASS\", wavelength);\n    else begin\n      $display(\"  30 MHz   |    10   |   %3d   | FAIL\", wavelength);\n      errors = errors + 1;\n    end\n\n    $display(\"-------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed\");\n    \n    $finish;\n  end\n\nendmodule\n"
        }
    ],
    "Climate": [
        {
            "module": "carbon_footprint",
            "Problem": "Implement a Verilog module that simulates a carbon footprint calculator. The module should take three 8-bit inputs representing energy consumption (kWh), transportation distance (km), and waste production (kg). The output is a 16-bit unsigned integer representing the total carbon footprint, calculated as: Footprint = (energy * 0.85) + (distance * 0.2) + (waste * 0.1).",
            "Module header": "module carbon_footprint (\n    input [7:0] energy,\n    input [7:0] distance,\n    input [7:0] waste,\n    output [15:0] footprint\n);",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_carbon_footprint;\n\n  // Testbench signals\n  reg  [7:0] energy;\n  reg  [7:0] distance;\n  reg  [7:0] waste;\n  wire [15:0] footprint;\n  \n  integer errors;\n  \n  // Instantiate the Unit Under Test (UUT)\n  carbon_footprint uut (\n    .energy(energy),\n    .distance(distance),\n    .waste(waste),\n    .footprint(footprint)\n  );\n  \n  initial begin\n    errors = 0;\n    \n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input            | Expected | Output | Pass/Fail \");\n    $display(\"-------------------------------------\");\n    \n    // Test Case 1:\n    // Inputs: energy = 100, distance = 50, waste = 25\n    // Calculations:\n    //   energy_term   = 100 * 85 = 8500\n    //   distance_term = 50 * 20  = 1000\n    //   waste_term    = 25 * 10  = 250\n    //   Total       = 8500 + 1000 + 250 = 9750\n    //   footprint   = 9750 / 100 = 97 (truncated)\n    energy = 8'd100; distance = 8'd50; waste = 8'd25;\n    #10;\n    if (footprint == 16'd97)\n      $display(\"   1: E=%3d, D=%3d, W=%3d |    97   |  %3d   | PASS\", energy, distance, waste, footprint);\n    else begin\n      $display(\"   1: E=%3d, D=%3d, W=%3d |    97   |  %3d   | FAIL\", energy, distance, waste, footprint);\n      errors = errors + 1;\n    end\n    \n    // Test Case 2:\n    // Inputs: energy = 0, distance = 0, waste = 0\n    // Expected footprint = 0\n    energy = 8'd0; distance = 8'd0; waste = 8'd0;\n    #10;\n    if (footprint == 16'd0)\n      $display(\"   2: E=%3d, D=%3d, W=%3d |     0   |  %3d   | PASS\", energy, distance, waste, footprint);\n    else begin\n      $display(\"   2: E=%3d, D=%3d, W=%3d |     0   |  %3d   | FAIL\", energy, distance, waste, footprint);\n      errors = errors + 1;\n    end\n    \n    \n    // Test Case 4:\n    // Inputs: energy = 50, distance = 100, waste = 200\n    // Calculations:\n    //   energy_term   = 50 * 85 = 4250\n    //   distance_term = 100 * 20 = 2000\n    //   waste_term    = 200 * 10 = 2000\n    //   Total = 4250 + 2000 + 2000 = 8250\n    //   footprint = 8250 / 100 = 82 (truncated)\n    energy = 8'd50; distance = 8'd100; waste = 8'd200;\n    #10;\n    if (footprint == 16'd82)\n      $display(\"   4: E=%3d, D=%3d, W=%3d |    82   |  %3d   | PASS\", energy, distance, waste, footprint);\n    else begin\n      $display(\"   4: E=%3d, D=%3d, W=%3d |    82   |  %3d   | FAIL\", energy, distance, waste, footprint);\n      errors = errors + 1;\n    end\n    \n    // Test Case 5:\n    // Inputs: energy = 10, distance = 20, waste = 30\n    // Calculations:\n    //   energy_term   = 10 * 85 = 850\n    //   distance_term = 20 * 20 = 400\n    //   waste_term    = 30 * 10 = 300\n    //   Total = 850 + 400 + 300 = 1550\n    //   footprint = 1550 / 100 = 15 (truncated)\n    energy = 8'd10; distance = 8'd20; waste = 8'd30;\n    #10;\n    if (footprint == 16'd15)\n      $display(\"   5: E=%3d, D=%3d, W=%3d |    15   |  %3d   | PASS\", energy, distance, waste, footprint);\n    else begin\n      $display(\"   5: E=%3d, D=%3d, W=%3d |    15   |  %3d   | FAIL\", energy, distance, waste, footprint);\n      errors = errors + 1;\n    end\n    \n    $display(\"-------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed\");\n      \n    $finish;\n  end\n  \nendmodule\n"
        },
        {
            "module": "heat_index",
            "Problem": "Implement a Verilog module that calculates the heat index (feels-like temperature) using a polynomial model. The heat index formula is given as: Heat Index = C1 + C2*T + C3*R + C4*T*R + C5*T^2 + C6*R^2 + C7*T^2*R + C8*T*R^2 + C9*T^2*R^2, where T is the temperature in Celsius and R is the relative humidity in percentage. The constants C1 through C9 are 16-bit signed integer coefficients that define the model. The module takes T and R as 8-bit unsigned inputs, along with nine 16-bit signed coefficients (C1 to C9), and produces a 16-bit signed output representing the computed heat index.",
            "Module header": "module heat_index (\n    input [7:0] temperature,   // Temperature in Celsius\n    input [7:0] humidity,      // Humidity in percentage\n    input signed [15:0] C1, C2, C3, C4, C5, C6, C7, C8, C9,    // Quartic T^2*R^2\n    output signed [15:0] heat_index // Heat Index in Celsius\n);",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_heat_index;\n\n  // Testbench signals\n  reg [7:0] temperature;\n  reg [7:0] humidity;\n  reg signed [15:0] C1, C2, C3, C4, C5, C6, C7, C8, C9;\n  wire signed [15:0] heat_index;\n  integer errors;\n  \n  // Instantiate the Unit Under Test (UUT)\n  heat_index uut (\n    .temperature(temperature),\n    .humidity(humidity),\n    .C1(C1),\n    .C2(C2),\n    .C3(C3),\n    .C4(C4),\n    .C5(C5),\n    .C6(C6),\n    .C7(C7),\n    .C8(C8),\n    .C9(C9),\n    .heat_index(heat_index)\n  );\n  \n  initial begin\n    errors = 0;\n    \n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input                           | Expected | Output | Pass/Fail \");\n    $display(\"---------------------------------------------------------------\");\n    \n    // Test Case 1:\n    // Use a simplified formula: heat_index = C1 + C2*T + C3*R.\n    // Coefficients: C1 = -80, C2 = 11, C3 = 1; all others = 0.\n    // For temperature = 30, humidity = 70:\n    // Expected = -80 + (11 * 30) + 70 = -80 + 330 + 70 = 320.\n    temperature = 8'd30;\n    humidity = 8'd70;\n    C1 = -16'sd80;\n    C2 = 16'sd11;\n    C3 = 16'sd1;\n    C4 = 16'sd0;\n    C5 = 16'sd0;\n    C6 = 16'sd0;\n    C7 = 16'sd0;\n    C8 = 16'sd0;\n    C9 = 16'sd0;\n    #10;\n    if (heat_index === 16'sd320)\n      $display(\"   1: T=%3d, R=%3d           |   320   | %4d  | PASS\", temperature, humidity, heat_index);\n    else begin\n      $display(\"   1: T=%3d, R=%3d           |   320   | %4d  | FAIL\", temperature, humidity, heat_index);\n      errors = errors + 1;\n    end\n    \n    // Test Case 2:\n    // Use quadratic terms: heat_index = T + R + T^2 + R^2.\n    // Coefficients: C1=0, C2=1, C3=1, C5=1, C6=1; others = 0.\n    // For temperature = 10, humidity = 20:\n    // Expected = 10 + 20 + (10^2) + (20^2) = 10 + 20 + 100 + 400 = 530.\n    temperature = 8'd10;\n    humidity = 8'd20;\n    C1 = 16'sd0;\n    C2 = 16'sd1;\n    C3 = 16'sd1;\n    C4 = 16'sd0;\n    C5 = 16'sd1;\n    C6 = 16'sd1;\n    C7 = 16'sd0;\n    C8 = 16'sd0;\n    C9 = 16'sd0;\n    #10;\n    if (heat_index === 16'sd530)\n      $display(\"   2: T=%3d, R=%3d           |   530   | %4d  | PASS\", temperature, humidity, heat_index);\n    else begin\n      $display(\"   2: T=%3d, R=%3d           |   530   | %4d  | FAIL\", temperature, humidity, heat_index);\n      errors = errors + 1;\n    end\n    \n    // Test Case 3:\n    // Use an interaction term: heat_index = 10 + 2*T + 3*R + T*R.\n    // Coefficients: C1 = 10, C2 = 2, C3 = 3, C4 = 1; others = 0.\n    // For temperature = 20, humidity = 30:\n    // Expected = 10 + 40 + 90 + 600 = 740.\n    temperature = 8'd20;\n    humidity = 8'd30;\n    C1 = 16'sd10;\n    C2 = 16'sd2;\n    C3 = 16'sd3;\n    C4 = 16'sd1;\n    C5 = 16'sd0;\n    C6 = 16'sd0;\n    C7 = 16'sd0;\n    C8 = 16'sd0;\n    C9 = 16'sd0;\n    #10;\n    if (heat_index === 16'sd740)\n      $display(\"   3: T=%3d, R=%3d           |   740   | %4d  | PASS\", temperature, humidity, heat_index);\n    else begin\n      $display(\"   3: T=%3d, R=%3d           |   740   | %4d  | FAIL\", temperature, humidity, heat_index);\n      errors = errors + 1;\n    end\n    \n    // Test Case 4:\n    // Use quadratic difference: heat_index = T^2 - R^2.\n    // Coefficients: C1=0, C2=0, C3=0, C4=0, C5=1, C6=-1; others = 0.\n    // For temperature = 50, humidity = 20:\n    // Expected = (50^2) - (20^2) = 2500 - 400 = 2100.\n    temperature = 8'd50;\n    humidity = 8'd20;\n    C1 = 16'sd0;\n    C2 = 16'sd0;\n    C3 = 16'sd0;\n    C4 = 16'sd0;\n    C5 = 16'sd1;\n    C6 = -16'sd1;\n    C7 = 16'sd0;\n    C8 = 16'sd0;\n    C9 = 16'sd0;\n    #10;\n    if (heat_index === 16'sd2100)\n      $display(\"   4: T=%3d, R=%3d           |  2100   | %4d  | PASS\", temperature, humidity, heat_index);\n    else begin\n      $display(\"   4: T=%3d, R=%3d           |  2100   | %4d  | FAIL\", temperature, humidity, heat_index);\n      errors = errors + 1;\n    end\n    \n    // Test Case 5:\n    // Use higher-order terms: heat_index = T^2*R - T*R^2 + T^2*R^2.\n    // Coefficients: C1=0, C2=0, C3=0, C4=0, C5=0, C6=0, C7=1, C8=-1, C9=1.\n    // For temperature = 2, humidity = 3:\n    // Compute: T^2 = 4, R^2 = 9, so:\n    //   T^2*R = 4*3 = 12, T*R^2 = 2*9 = 18, T^2*R^2 = 4*9 = 36.\n    // Expected = 12 - 18 + 36 = 30.\n    temperature = 8'd2;\n    humidity = 8'd3;\n    C1 = 16'sd0;\n    C2 = 16'sd0;\n    C3 = 16'sd0;\n    C4 = 16'sd0;\n    C5 = 16'sd0;\n    C6 = 16'sd0;\n    C7 = 16'sd1;\n    C8 = -16'sd1;\n    C9 = 16'sd1;\n    #10;\n    if (heat_index === 16'sd30)\n      $display(\"   5: T=%3d, R=%3d           |    30   | %4d  | PASS\", temperature, humidity, heat_index);\n    else begin\n      $display(\"   5: T=%3d, R=%3d           |    30   | %4d  | FAIL\", temperature, humidity, heat_index);\n      errors = errors + 1;\n    end\n    \n    $display(\"---------------------------------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed: %0d error(s)\", errors);\n      \n    $finish;\n  end\n\nendmodule\n"
        },
        {
            "module": "air_quality_index",
            "Problem": "Implement a Verilog module that calculates the air quality index (AQI) based on three 8-bit inputs representing PM2.5, PM10, and NO2 concentrations. The AQI is calculated as: AQI = max(PM2.5, PM10, NO2) * 0.5 + min(PM2.5, PM10, NO2) * 0.3 + (PM2.5 + PM10 + NO2) * 0.2.",
            "Module header": "module air_quality_index (\n    input [7:0] pm2_5,\n    input [7:0] pm10,\n    input [7:0] no2,\n    output [15:0] aqi\n);",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_air_quality_index;\n\n  // Testbench signals to drive the inputs.\n  reg [7:0] pm2_5;\n  reg [7:0] pm10;\n  reg [7:0] no2;\n  // Output from the Unit Under Test (UUT).\n  wire [15:0] aqi;\n  \n  // Error counter.\n  integer errors;\n  \n  // Instantiate the Unit Under Test.\n  air_quality_index uut (\n    .pm2_5(pm2_5),\n    .pm10(pm10),\n    .no2(no2),\n    .aqi(aqi)\n  );\n  \n  initial begin\n    errors = 0;\n    \n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input               | Expected | Output | Pass/Fail \");\n    $display(\"-------------------------------------\");\n    \n\n\n    // Test Case 3:\n    // pm2_5 = 0, pm10 = 0, no2 = 0.\n    // All terms are zero; expected AQI = 0.\n    pm2_5 = 8'd0;  pm10 = 8'd0;  no2 = 8'd0;\n    #10;\n    if (aqi == 16'd0)\n      $display(\"   3: PM2.5=%3d, PM10=%3d, NO2=%3d |    0    |  %3d   | PASS\", pm2_5, pm10, no2, aqi);\n    else begin\n      $display(\"   3: PM2.5=%3d, PM10=%3d, NO2=%3d |    0    |  %3d   | FAIL\", pm2_5, pm10, no2, aqi);\n      errors = errors + 1;\n    end\n\n    // Test Case 4:\n    // pm2_5 = 255, pm10 = 200, no2 = 100.\n    // max = 255, min = 100, sum = 555.\n    // numerator = 255*128 + 100*77 + 555*51 = 32640 + 7700 + 28305 = 68645.\n    // AQI = 68645 / 256 = 268.\n    pm2_5 = 8'd255;  pm10 = 8'd200;  no2 = 8'd100;\n    #10;\n    if (aqi == 16'd268)\n      $display(\"   4: PM2.5=%3d, PM10=%3d, NO2=%3d |   268   |  %3d   | PASS\", pm2_5, pm10, no2, aqi);\n    else begin\n      $display(\"   4: PM2.5=%3d, PM10=%3d, NO2=%3d |   268   |  %3d   | FAIL\", pm2_5, pm10, no2, aqi);\n      errors = errors + 1;\n    end\n\n    // Test Case 5:\n    // pm2_5 = 123, pm10 = 45, no2 = 67.\n    // max = 123, min = 45, sum = 235.\n    // numerator = 123*128 + 45*77 + 235*51 = 15744 + 3465 + 11985 = 31194.\n    // AQI = 31194 / 256 = 121.\n    pm2_5 = 8'd123;  pm10 = 8'd45;  no2 = 8'd67;\n    #10;\n    if (aqi == 16'd121)\n      $display(\"   5: PM2.5=%3d, PM10=%3d, NO2=%3d |   121   |  %3d   | PASS\", pm2_5, pm10, no2, aqi);\n    else begin\n      $display(\"   5: PM2.5=%3d, PM10=%3d, NO2=%3d |   121   |  %3d   | FAIL\", pm2_5, pm10, no2, aqi);\n      errors = errors + 1;\n    end\n\n    $display(\"-------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed\");\n    \n    $finish;\n  end\n\nendmodule\n"
        },
        {
            "module": "solar_radiation_average",
            "Problem": "Implement a solar radiation averaging module that computes the average of eight hourly 8-bit solar radiation measurements.",
            "Module header": "module solar_radiation_average (\n    input [7:0] r0, r1, r2, r3, r4, r5, r6, r7,\n    output [7:0] avg_radiation\n);\n    // Calculate average solar radiation\n    assign avg_radiation = (r0 + r1 + r2 + r3 + r4 + r5 + r6 + r7) / 8;\nendmodule",
            "Testbench": "`timescale 1ns/1ps\nmodule tb_solar_radiation_average;\n\n  // Testbench signals for inputs and output.\n  reg [7:0] r0, r1, r2, r3, r4, r5, r6, r7;\n  wire [7:0] avg_radiation;\n  \n  // Error counter (simulation only).\n  integer errors;\n  integer expected;\n  \n  // Instantiate the Unit Under Test (UUT)\n  solar_radiation_average uut (\n    .r0(r0), .r1(r1), .r2(r2), .r3(r3), .r4(r4), .r5(r5), .r6(r6), .r7(r7),\n    .avg_radiation(avg_radiation)\n  );\n  \n  initial begin\n    errors = 0;\n    \n    $display(\"==========Testbench results==========\");\n    $display(\"=====================================\");\n    $display(\" Test Input                                 | Expected | Output | Pass/Fail \");\n    $display(\"-------------------------------------\");\n    \n    // Test Case 1: All zeros.\n    r0 = 8'd0;  r1 = 8'd0;  r2 = 8'd0;  r3 = 8'd0;\n    r4 = 8'd0;  r5 = 8'd0;  r6 = 8'd0;  r7 = 8'd0;\n    expected = 0; // (0+0+...+0)/8 = 0\n    #10;\n    if (avg_radiation == expected)\n      $display(\"   1:  0, 0, 0, 0, 0, 0, 0, 0               |   %3d    |   %3d   | PASS\", expected, avg_radiation);\n    else begin\n      $display(\"   1:  0, 0, 0, 0, 0, 0, 0, 0               |   %3d    |   %3d   | FAIL\", expected, avg_radiation);\n      errors = errors + 1;\n    end\n    \n    // Test Case 2: All maximum values (255).\n    r0 = 8'd255; r1 = 8'd255; r2 = 8'd255; r3 = 8'd255;\n    r4 = 8'd255; r5 = 8'd255; r6 = 8'd255; r7 = 8'd255;\n    expected = 255; // (8*255=2040, 2040/8 = 255)\n    #10;\n    if (avg_radiation == expected)\n      $display(\"   2:255,255,255,255,255,255,255,255       |   %3d    |   %3d   | PASS\", expected, avg_radiation);\n    else begin\n      $display(\"   2:255,255,255,255,255,255,255,255       |   %3d    |   %3d   | FAIL\", expected, avg_radiation);\n      errors = errors + 1;\n    end\n    \n    // Test Case 3: 10, 20, 30, 40, 50, 60, 70, 80.\n    r0 = 8'd10;  r1 = 8'd20;  r2 = 8'd30;  r3 = 8'd40;\n    r4 = 8'd50;  r5 = 8'd60;  r6 = 8'd70;  r7 = 8'd80;\n    expected = 45; // (10+20+30+40+50+60+70+80 = 360; 360/8 = 45)\n    #10;\n    if (avg_radiation == expected)\n      $display(\"   3:10,20,30,40,50,60,70,80               |   %3d    |   %3d   | PASS\", expected, avg_radiation);\n    else begin\n      $display(\"   3:10,20,30,40,50,60,70,80               |   %3d    |   %3d   | FAIL\", expected, avg_radiation);\n      errors = errors + 1;\n    end\n\n    // Test Case 4: 1, 2, 3, 4, 5, 6, 7, 8.\n    r0 = 8'd1;   r1 = 8'd2;   r2 = 8'd3;   r3 = 8'd4;\n    r4 = 8'd5;   r5 = 8'd6;   r6 = 8'd7;   r7 = 8'd8;\n    expected = 4;  // (1+2+3+4+5+6+7+8 = 36; 36/8 = 4 when using integer division)\n    #10;\n    if (avg_radiation == expected)\n      $display(\"   4: 1, 2, 3, 4, 5, 6, 7, 8               |   %3d    |   %3d   | PASS\", expected, avg_radiation);\n    else begin\n      $display(\"   4: 1, 2, 3, 4, 5, 6, 7, 8               |   %3d    |   %3d   | FAIL\", expected, avg_radiation);\n      errors = errors + 1;\n    end\n\n    // Test Case 5: 100, 110, 120, 130, 140, 150, 160, 170.\n    r0 = 8'd100; r1 = 8'd110; r2 = 8'd120; r3 = 8'd130;\n    r4 = 8'd140; r5 = 8'd150; r6 = 8'd160; r7 = 8'd170;\n    expected = 135; // (100+110+120+130+140+150+160+170 = 1080; 1080/8 = 135)\n    #10;\n    if (avg_radiation == expected)\n      $display(\"   5:100,110,120,130,140,150,160,170         |   %3d    |   %3d   | PASS\", expected, avg_radiation);\n    else begin\n      $display(\"   5:100,110,120,130,140,150,160,170         |   %3d    |   %3d   | FAIL\", expected, avg_radiation);\n      errors = errors + 1;\n    end\n    \n    $display(\"-------------------------------------\");\n    if (errors == 0)\n      $display(\"All tests passed\");\n    else\n      $display(\"Some tests failed\");\n    \n    $finish;\n  end\n\nendmodule\n"
        }
    ]
}